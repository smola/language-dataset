Released XU*8*585 SEQ #485
Extracted from mail message
**KIDS**:XU*8.0*585^

**INSTALL NAME**
XU*8.0*585
"BLD",1395,0)
XU*8.0*585^KERNEL^0^3120911^y
"BLD",1395,1,0)
^^2^2^3111013^
"BLD",1395,1,1,0)
Please see the National Patch Module for the patch description. 
"BLD",1395,1,2,0)

"BLD",1395,4,0)
^9.64PA^3.52^2
"BLD",1395,4,3.5,0)
3.5
"BLD",1395,4,3.5,2,0)
^9.641^3.5^1
"BLD",1395,4,3.5,2,3.5,0)
DEVICE  (File-top level)
"BLD",1395,4,3.5,2,3.5,1,0)
^9.6411^2^2
"BLD",1395,4,3.5,2,3.5,1,.13,0)
PURGE OLD PRINT QUEUE FILES
"BLD",1395,4,3.5,2,3.5,1,2,0)
TYPE
"BLD",1395,4,3.5,222)
y^n^p^^^^n^^n
"BLD",1395,4,3.5,224)

"BLD",1395,4,3.52,0)
3.52
"BLD",1395,4,3.52,222)
y^n^f^^^^n
"BLD",1395,4,"APDD",3.5,3.5)

"BLD",1395,4,"APDD",3.5,3.5,.13)

"BLD",1395,4,"APDD",3.5,3.5,2)

"BLD",1395,4,"B",3.5,3.5)

"BLD",1395,4,"B",3.52,3.52)

"BLD",1395,6.3)
22
"BLD",1395,"ABPKG")
n
"BLD",1395,"INID")
n^n
"BLD",1395,"INIT")
POST^XU8P585
"BLD",1395,"KRN",0)
^9.67PA^9002226^21
"BLD",1395,"KRN",.4,0)
.4
"BLD",1395,"KRN",.401,0)
.401
"BLD",1395,"KRN",.402,0)
.402
"BLD",1395,"KRN",.403,0)
.403
"BLD",1395,"KRN",.403,"NM",0)
^9.68A^1^1
"BLD",1395,"KRN",.403,"NM",1,0)
XUDEVICE PQ    FILE #3.5^3.5^0
"BLD",1395,"KRN",.403,"NM","B","XUDEVICE PQ    FILE #3.5",1)

"BLD",1395,"KRN",.5,0)
.5
"BLD",1395,"KRN",.84,0)
.84
"BLD",1395,"KRN",3.6,0)
3.6
"BLD",1395,"KRN",3.8,0)
3.8
"BLD",1395,"KRN",9.2,0)
9.2
"BLD",1395,"KRN",9.8,0)
9.8
"BLD",1395,"KRN",9.8,"NM",0)
^9.68A^7^7
"BLD",1395,"KRN",9.8,"NM",1,0)
ZISX^^0^B1066676
"BLD",1395,"KRN",9.8,"NM",2,0)
ZISPQ^^0^B101069140
"BLD",1395,"KRN",9.8,"NM",3,0)
ZIS2^^0^B19905647
"BLD",1395,"KRN",9.8,"NM",4,0)
ZISEDIT^^0^B2972844
"BLD",1395,"KRN",9.8,"NM",5,0)
ZISFM^^0^B3818871
"BLD",1395,"KRN",9.8,"NM",6,0)
ZISC^^0^B23112618
"BLD",1395,"KRN",9.8,"NM",7,0)
ZIS6^^0^B21650565
"BLD",1395,"KRN",9.8,"NM","B","ZIS2",3)

"BLD",1395,"KRN",9.8,"NM","B","ZIS6",7)

"BLD",1395,"KRN",9.8,"NM","B","ZISC",6)

"BLD",1395,"KRN",9.8,"NM","B","ZISEDIT",4)

"BLD",1395,"KRN",9.8,"NM","B","ZISFM",5)

"BLD",1395,"KRN",9.8,"NM","B","ZISPQ",2)

"BLD",1395,"KRN",9.8,"NM","B","ZISX",1)

"BLD",1395,"KRN",19,0)
19
"BLD",1395,"KRN",19,"NM",0)
^9.68A^3^3
"BLD",1395,"KRN",19,"NM",1,0)
XUDEVEDIT^^2
"BLD",1395,"KRN",19,"NM",2,0)
XUDEVEDITPQ^^0
"BLD",1395,"KRN",19,"NM",3,0)
XU PURGE PRINT QUEUE HFS FILES^^0
"BLD",1395,"KRN",19,"NM","B","XU PURGE PRINT QUEUE HFS FILES",3)

"BLD",1395,"KRN",19,"NM","B","XUDEVEDIT",1)

"BLD",1395,"KRN",19,"NM","B","XUDEVEDITPQ",2)

"BLD",1395,"KRN",19.1,0)
19.1
"BLD",1395,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",1395,"KRN",101,0)
101
"BLD",1395,"KRN",409.61,0)
409.61
"BLD",1395,"KRN",771,0)
771
"BLD",1395,"KRN",779.2,0)
779.2
"BLD",1395,"KRN",870,0)
870
"BLD",1395,"KRN",8989.51,0)
8989.51
"BLD",1395,"KRN",8989.52,0)
8989.52
"BLD",1395,"KRN",8994,0)
8994
"BLD",1395,"KRN",9002226,0)
9002226
"BLD",1395,"KRN","B",.4,.4)

"BLD",1395,"KRN","B",.401,.401)

"BLD",1395,"KRN","B",.402,.402)

"BLD",1395,"KRN","B",.403,.403)

"BLD",1395,"KRN","B",.5,.5)

"BLD",1395,"KRN","B",.84,.84)

"BLD",1395,"KRN","B",3.6,3.6)

"BLD",1395,"KRN","B",3.8,3.8)

"BLD",1395,"KRN","B",9.2,9.2)

"BLD",1395,"KRN","B",9.8,9.8)

"BLD",1395,"KRN","B",19,19)

"BLD",1395,"KRN","B",19.1,19.1)

"BLD",1395,"KRN","B",101,101)

"BLD",1395,"KRN","B",409.61,409.61)

"BLD",1395,"KRN","B",771,771)

"BLD",1395,"KRN","B",779.2,779.2)

"BLD",1395,"KRN","B",870,870)

"BLD",1395,"KRN","B",8989.51,8989.51)

"BLD",1395,"KRN","B",8989.52,8989.52)

"BLD",1395,"KRN","B",8994,8994)

"BLD",1395,"KRN","B",9002226,9002226)

"BLD",1395,"PRE")
XU8P585
"BLD",1395,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",1395,"QUES",0)
^9.62^^
"BLD",1395,"REQB",0)
^9.611^1^1
"BLD",1395,"REQB",1,0)
XU*8.0*546^2
"BLD",1395,"REQB","B","XU*8.0*546",1)

"FIA",3.5)
DEVICE
"FIA",3.5,0)
^%ZIS(1,
"FIA",3.5,0,0)
3.5Is
"FIA",3.5,0,1)
y^n^p^^^^n^^n
"FIA",3.5,0,10)

"FIA",3.5,0,11)

"FIA",3.5,0,"RLRO")

"FIA",3.5,0,"VR")
8.0^XU
"FIA",3.5,3.5)
1
"FIA",3.5,3.5,.13)

"FIA",3.5,3.5,2)

"FIA",3.52)
PRINT QUEUE JOB
"FIA",3.52,0)
^%ZIS(3.52,
"FIA",3.52,0,0)
3.52PI
"FIA",3.52,0,1)
y^n^f^^^^n
"FIA",3.52,0,10)

"FIA",3.52,0,11)

"FIA",3.52,0,"RLRO")

"FIA",3.52,0,"VR")
8.0^XU
"FIA",3.52,3.52)
0
"INIT")
POST^XU8P585
"IX",3.52,3.52,"C",0)
3.52^C^Used to find the print jobs belonging to a specific individual.^R^^F^IR^I^3.52^^^^^LS
"IX",3.52,3.52,"C",.1,0)
^^3^3^3111107^^
"IX",3.52,3.52,"C",.1,1,0)
This index is on the owner of the print job, i.e., the person who requested
"IX",3.52,3.52,"C",.1,2,0)
to print the document.  
"IX",3.52,3.52,"C",.1,3,0)

"IX",3.52,3.52,"C",1)
S ^%ZIS(3.52,"C",X,DA)=""
"IX",3.52,3.52,"C",2)
K ^%ZIS(3.52,"C",X,DA)
"IX",3.52,3.52,"C",2.5)
K ^%ZIS(3.52,"C")
"IX",3.52,3.52,"C",11.1,0)
^.114IA^1^1
"IX",3.52,3.52,"C",11.1,1,0)
1^F^3.52^.04^^1^F
"IX",3.52,3.52,"D",0)
3.52^D^Used to do a lookup based on the name of the host file.^R^^F^IR^I^3.52^^^^^LS
"IX",3.52,3.52,"D",.1,0)
^^3^3^3111107^
"IX",3.52,3.52,"D",.1,1,0)
This index cross-references the name of the host file to the print job that
"IX",3.52,3.52,"D",.1,2,0)
it was created for.
"IX",3.52,3.52,"D",.1,3,0)

"IX",3.52,3.52,"D",1)
S ^%ZIS(3.52,"D",$E(X,1,30),DA)=""
"IX",3.52,3.52,"D",2)
K ^%ZIS(3.52,"D",$E(X,1,30),DA)
"IX",3.52,3.52,"D",2.5)
K ^%ZIS(3.52,"D")
"IX",3.52,3.52,"D",11.1,0)
^.114IA^1^1
"IX",3.52,3.52,"D",11.1,1,0)
1^F^3.52^.06^30^1^F
"IX",3.52,3.52,"E",0)
3.52^E^Used to manage print jobs. For example,purging.^R^^R^IR^I^3.52^^^^^LS
"IX",3.52,3.52,"E",.1,0)
^^7^7^3111102^^^
"IX",3.52,3.52,"E",.1,1,0)
The format of this index is as follows:
"IX",3.52,3.52,"E",.1,2,0)

"IX",3.52,3.52,"E",.1,3,0)
^%ZIS(3.52,"E", <HFS DIRECTORY field (#.09)>, <DEVICE field (#.01)>,
"IX",3.52,3.52,"E",.1,4,0)
<STATUS field (#.07)>, <DT/TM HOST FILE CREATED field (#.02), 
"IX",3.52,3.52,"E",.1,5,0)
<IEN of record>)="" 
"IX",3.52,3.52,"E",.1,6,0)

"IX",3.52,3.52,"E",.1,7,0)

"IX",3.52,3.52,"E",1)
S ^%ZIS(3.52,"E",$E(X(1),1,1),$E(X(2),1,5),$E(X(3),1,2),$E(X(4),1,12),DA)=""
"IX",3.52,3.52,"E",2)
K ^%ZIS(3.52,"E",$E(X(1),1,1),$E(X(2),1,5),$E(X(3),1,2),$E(X(4),1,12),DA)
"IX",3.52,3.52,"E",2.5)
K ^%ZIS(3.52,"E")
"IX",3.52,3.52,"E",11.1,0)
^.114IA^4^4
"IX",3.52,3.52,"E",11.1,1,0)
1^F^3.52^.09^1^1^F
"IX",3.52,3.52,"E",11.1,2,0)
2^F^3.52^.01^5^2^F
"IX",3.52,3.52,"E",11.1,3,0)
3^F^3.52^.07^2^3^F
"IX",3.52,3.52,"E",11.1,4,0)
4^F^3.52^.02^12^4^F
"IX",3.52,3.52,"F",0)
3.52^F^Used to find jobs for a specific print queue.^R^^F^IR^I^3.52^^^^^LS
"IX",3.52,3.52,"F",.1,0)
^^2^2^3111107^^
"IX",3.52,3.52,"F",.1,1,0)
This index cross-references the print job to the queue that it was placed on.
"IX",3.52,3.52,"F",.1,2,0)

"IX",3.52,3.52,"F",1)
S ^%ZIS(3.52,"F",$E(X,1,31),DA)=""
"IX",3.52,3.52,"F",2)
K ^%ZIS(3.52,"F",$E(X,1,31),DA)
"IX",3.52,3.52,"F",2.5)
K ^%ZIS(3.52,"F")
"IX",3.52,3.52,"F",11.1,0)
^.114IA^1^1
"IX",3.52,3.52,"F",11.1,1,0)
1^F^3.52^.05^31^1^F
"IX",3.52,3.52,"G",0)
3.52^G^Used to find the entry matching the job id returned by the os.^R^^F^IR^I^3.52^^^^^LS
"IX",3.52,3.52,"G",.1,0)
^^4^4^3111107^
"IX",3.52,3.52,"G",.1,1,0)
This index cross-references the job identifier provided by the 
"IX",3.52,3.52,"G",.1,2,0)
operating system when the job was submitted to the job record in the Kernel
"IX",3.52,3.52,"G",.1,3,0)
PRINT QUEUE JOBS file.  
"IX",3.52,3.52,"G",.1,4,0)

"IX",3.52,3.52,"G",1)
S ^%ZIS(3.52,"G",$E(X,1,30),DA)=""
"IX",3.52,3.52,"G",2)
K ^%ZIS(3.52,"G",$E(X,1,30),DA)
"IX",3.52,3.52,"G",2.5)
K ^%ZIS(3.52,"G")
"IX",3.52,3.52,"G",11.1,0)
^.114IA^1^1
"IX",3.52,3.52,"G",11.1,1,0)
1^F^3.52^.08^30^1^F
"KRN",.403,72,-1)
0^1
"KRN",.403,72,0)
XUDEVICE PQ^^^^2921019^^^3.5^0^0^1
"KRN",.403,72,40,0)
^.4031I^1^1
"KRN",.403,72,40,1,0)
1^XUDEVICE PQ HDR^1,1
"KRN",.403,72,40,1,1)
Page 1 of 1
"KRN",.403,72,40,1,40,0)
^.4032PI^315^1
"KRN",.403,72,40,1,40,315,0)
XUDEVICE PQ^1^2,1^e
"KRN",.404,315,0)
XUDEVICE PQ^3.5
"KRN",.404,315,11)

"KRN",.404,315,15,0)
^^1^1^3111026^
"KRN",.404,315,15,1,0)

"KRN",.404,315,40,0)
^.4044I^24^12
"KRN",.404,315,40,1,0)
1^NAME^3
"KRN",.404,315,40,1,1)
.01
"KRN",.404,315,40,1,2)
2,7^30^2,1
"KRN",.404,315,40,2,0)
2^LOCATION^3
"KRN",.404,315,40,2,1)
.02
"KRN",.404,315,40,2,2)
2,54^20^2,44
"KRN",.404,315,40,3,0)
3^PRIMARY PRINT QUEUE ($I field)^3
"KRN",.404,315,40,3,1)
1
"KRN",.404,315,40,3,2)
4,40^34^4,1
"KRN",.404,315,40,7,0)
5^SUBTYPE^3
"KRN",.404,315,40,7,1)
3
"KRN",.404,315,40,7,2)
8,10^25^8,1
"KRN",.404,315,40,10,0)
7^MARGIN WIDTH^3
"KRN",.404,315,40,10,1)
9
"KRN",.404,315,40,10,2)
10,15^3^10,1
"KRN",.404,315,40,11,0)
8^PAGE LENGTH^3
"KRN",.404,315,40,11,1)
11
"KRN",.404,315,40,11,2)
10,39^6^10,26
"KRN",.404,315,40,19,0)
10^  PRE-OPEN EXECUTE^3
"KRN",.404,315,40,19,1)
19.7
"KRN",.404,315,40,19,2)
12,21^57^12,1
"KRN",.404,315,40,20,0)
11^POST-CLOSE EXECUTE^3
"KRN",.404,315,40,20,1)
19.8
"KRN",.404,315,40,20,2)
14,21^57^14,1
"KRN",.404,315,40,21,0)
6^QUEUING^3
"KRN",.404,315,40,21,1)
5.5
"KRN",.404,315,40,21,2)
8,61^11^8,52
"KRN",.404,315,40,22,0)
9^SUPPRESS FORM FEED^3
"KRN",.404,315,40,22,1)
11.2
"KRN",.404,315,40,22,2)
10,72^3^10,52
"KRN",.404,315,40,23,0)
12^PURGE OLD HOST FILES (YES/NO, set to NO only while troubleshooting)^3
"KRN",.404,315,40,23,1)
.13
"KRN",.404,315,40,23,2)
16,70^3^16,1
"KRN",.404,315,40,23,3)
YES
"KRN",.404,315,40,24,0)
4^SECONDARY PRINT QUEUE (mixed OS only)^3^^SECONDARY PRINT QUEUE NAME
"KRN",.404,315,40,24,1)
52
"KRN",.404,315,40,24,2)
6,40^34^6,1
"KRN",.404,316,0)
XUDEVICE PQ HDR^3.5
"KRN",.404,316,40,0)
^.4044I^1^1
"KRN",.404,316,40,1,0)
1^EDIT A PRINT QUEUE DEVICE^1^
"KRN",.404,316,40,1,2)
^^1,23
"KRN",19,183,-1)
2^1
"KRN",19,183,0)
XUDEVEDIT^Device Edit^^M^.5^^^^^^^^y
"KRN",19,183,10,0)
^19.01IP^10^10
"KRN",19,183,10,10,0)
1568^PQ^99
"KRN",19,183,10,10,"^")
XUDEVEDITPQ
"KRN",19,183,"U")
DEVICE EDIT
"KRN",19,1568,-1)
0^2
"KRN",19,1568,0)
XUDEVEDITPQ^Print Queue Edit^^R^^^^^^^^
"KRN",19,1568,1,0)
^19.06^2^2^3111026^^^
"KRN",19,1568,1,1,0)
This is a ScreenMan oriented edit option for editing print queue devices.
"KRN",19,1568,1,2,0)

"KRN",19,1568,25)
PQ^ZISEDIT
"KRN",19,1568,"U")
PRINT QUEUE EDIT
"KRN",19,1569,-1)
0^3
"KRN",19,1569,0)
XU PURGE PRINT QUEUE HFS FILES^PURGE PRINT QUEUE HOST FILES^^A^^^^^^^y^KERNEL^^1
"KRN",19,1569,1,0)
^^4^4^3111104^
"KRN",19,1569,1,1,0)
This option will purge old host files that were created for
"KRN",19,1569,1,2,0)
printing.  It will also purge old entries in the PRINT QUEUE JOBS file
"KRN",19,1569,1,3,0)
(#3.52). This option should be scheduled to run regularly. 
"KRN",19,1569,1,4,0)

"KRN",19,1569,10.1)
PURGE PQ HOST FILES
"KRN",19,1569,20)
D PURGE^ZISPQ
"KRN",19,1569,"U")
PURGE PRINT QUEUE HOST FILES
"MBREQ")
0
"ORD",8,.403)
.403;8;;;EDEOUT^DIFROMSO(.403,DA,"",XPDA);FPRE^DIFROMSI(.403,"",XPDA);EPRE^DIFROMSI(.403,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.403,DA,"",XPDA);DEL^DIFROMSK(.403,"",%)
"ORD",8,.403,0)
FORM
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",3,-1)
1^1
"PKG",3,0)
KERNEL^XU^SIGN-ON, SECURITY, MENU DRIVER, DEVICES, TASKMAN^
"PKG",3,20,0)
^9.402P^^0
"PKG",3,22,0)
^9.49I^1^1
"PKG",3,22,1,0)
8.0^3090706^3090706^6
"PKG",3,22,1,"PAH",1,0)
585^3120911^1000061
"PKG",3,22,1,"PAH",1,1,0)
^^2^2^3120911
"PKG",3,22,1,"PAH",1,1,1,0)
Please see the National Patch Module for the patch description. 
"PKG",3,22,1,"PAH",1,1,2,0)

"PRE")
XU8P585
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
8
"RTN","XU8P585")
0^^B15237979^n/a
"RTN","XU8P585",1,0)
XU8P585 ;ISF/CJM- Patch XU-585 Post init ;09/11/2012
"RTN","XU8P585",2,0)
 ;;8.0;KERNEL;**585**;;Build 22
"RTN","XU8P585",3,0)
 ;
"RTN","XU8P585",4,0)
ENVIR ;Environment check for XU*8.0*585
"RTN","XU8P585",5,0)
 I '$$CHECKDIR D
"RTN","XU8P585",6,0)
 .S XPDQUIT=2
"RTN","XU8P585",7,0)
 .W !,"The directory for the print files does not exist or the permissions were",!,"not correctly established"
"RTN","XU8P585",8,0)
 Q
"RTN","XU8P585",9,0)
POST ;
"RTN","XU8P585",10,0)
 N ERROR,OS
"RTN","XU8P585",11,0)
 D PATCH^ZTMGRSET(585)
"RTN","XU8P585",12,0)
 S OS=$$OS^%ZOSV()
"RTN","XU8P585",13,0)
 I OS'["VMS",OS'["UNIX" Q
"RTN","XU8P585",14,0)
 I $G(ERROR)<0 D BMES^XPDUTL("Failed to schedule the 'XU PURGE PRINT QUEUE HFS FILES' option! Please do so manually.")
"RTN","XU8P585",15,0)
 N IEN,DATA,OPTION
"RTN","XU8P585",16,0)
 S OPTION=$O(^DIC(19,"B","XU PURGE PRINT QUEUE HFS FILES",0))
"RTN","XU8P585",17,0)
 I 'OPTION D BMES^XPDUTL("Failed to schedule the XU PURGE PRINT QUEUE HFS FILES option!")
"RTN","XU8P585",18,0)
 I OPTION D
"RTN","XU8P585",19,0)
 .S IEN=$O(^DIC(19.2,"B",OPTION,0))
"RTN","XU8P585",20,0)
 .S DATA(.01)=OPTION
"RTN","XU8P585",21,0)
 .S DATA(2)=$$FMADD^XLFDT($$NOW^XLFDT,,1)
"RTN","XU8P585",22,0)
 .S DATA(6)="1H"
"RTN","XU8P585",23,0)
 .I IEN D
"RTN","XU8P585",24,0)
 ..I '$$UPD^HLOASUB1(19.2,IEN,.DATA) D BMES^XPDUTL("Failed to schedule the XU PURGE PRINT QUEUE HFS FILES option!")
"RTN","XU8P585",25,0)
 .E  D
"RTN","XU8P585",26,0)
 ..I '$$ADD^HLOASUB1(19.2,,.DATA) D BMES^XPDUTL("Failed to schedule the XU PURGE PRINT QUEUE HFS FILES option!")
"RTN","XU8P585",27,0)
 Q
"RTN","XU8P585",28,0)
 ;
"RTN","XU8P585",29,0)
CNVRT ;convert HFS type devices that call NVSPRTU to PQ type devices
"RTN","XU8P585",30,0)
 N DEVICE,NOW
"RTN","XU8P585",31,0)
 S NOW=$$DT^XLFDT()
"RTN","XU8P585",32,0)
 S DEVICE=0
"RTN","XU8P585",33,0)
 ;
"RTN","XU8P585",34,0)
 ;K ^XTMP("%ZIS HFS TO PQ") ;overlay old list if it exists
"RTN","XU8P585",35,0)
 ;
"RTN","XU8P585",36,0)
 S ^XTMP("%ZIS HFS TO PQ",0)=$$FMADD^XLFDT(NOW,180)_"^"_NOW
"RTN","XU8P585",37,0)
 F  S DEVICE=$O(^%ZIS(1,DEVICE)) Q:'DEVICE  D
"RTN","XU8P585",38,0)
 .I $P($G(^%ZIS(1,DEVICE,"TYPE")),"^")="HFS" D
"RTN","XU8P585",39,0)
 ..N SUBTYPE
"RTN","XU8P585",40,0)
 ..S SUBTYPE=$P($G(^%ZIS(1,DEVICE,"SUBTYPE")),"^")
"RTN","XU8P585",41,0)
 ..Q:'SUBTYPE
"RTN","XU8P585",42,0)
 ..I $G(^%ZIS(2,SUBTYPE,3))["CLOSE^NVSPRTU" D
"RTN","XU8P585",43,0)
 ...N DATA
"RTN","XU8P585",44,0)
 ...S DATA(2)="PQ"
"RTN","XU8P585",45,0)
 ...S ^XTMP("%ZIS HFS TO PQ",DEVICE)=""
"RTN","XU8P585",46,0)
 ...D UPD^ZISFM(3.5,DEVICE,.DATA)
"RTN","XU8P585",47,0)
 Q
"RTN","XU8P585",48,0)
 ;
"RTN","XU8P585",49,0)
UNDO ;undo the changes made by CNVRT conversion routine
"RTN","XU8P585",50,0)
 N DEVICE
"RTN","XU8P585",51,0)
 S DEVICE=0
"RTN","XU8P585",52,0)
 F  S DEVICE=$O(^XTMP("%ZIS HFS TO PQ",DEVICE)) Q:'DEVICE  D
"RTN","XU8P585",53,0)
 .N DATA
"RTN","XU8P585",54,0)
 .S DATA(2)="HFS"
"RTN","XU8P585",55,0)
 .D UPD^ZISFM(3.5,DEVICE,.DATA)
"RTN","XU8P585",56,0)
 Q
"RTN","XU8P585",57,0)
 ;
"RTN","XU8P585",58,0)
 ;
"RTN","XU8P585",59,0)
CHECKDIR() ;tests if the print_queues directory has been created properly
"RTN","XU8P585",60,0)
 ;
"RTN","XU8P585",61,0)
 ;if production and VMS or Linux the test is not needed
"RTN","XU8P585",62,0)
 N OS
"RTN","XU8P585",63,0)
 Q:'$$PROD^XUPROD() 1
"RTN","XU8P585",64,0)
 S OS=$$OS^%ZOSV()
"RTN","XU8P585",65,0)
 I OS'["VMS",OS'["UNIX" Q 1
"RTN","XU8P585",66,0)
 ;
"RTN","XU8P585",67,0)
 N DIR,FILE,IO,POP,HANDLE
"RTN","XU8P585",68,0)
 S DIR=$$DIR
"RTN","XU8P585",69,0)
 S FILE="TEST_"_$J
"RTN","XU8P585",70,0)
 S HANDLE="ZUHANDLE"
"RTN","XU8P585",71,0)
 ;
"RTN","XU8P585",72,0)
 I $$FEXIST(DIR_FILE) Q 1
"RTN","XU8P585",73,0)
 D OPEN^%ZISH(HANDLE,DIR,FILE,"W")
"RTN","XU8P585",74,0)
 Q:POP 0
"RTN","XU8P585",75,0)
 D CLOSE^%ZISH(HANDLE)
"RTN","XU8P585",76,0)
 D FDELETE(DIR_FILE)
"RTN","XU8P585",77,0)
 Q 1
"RTN","XU8P585",78,0)
 ;
"RTN","XU8P585",79,0)
 ;
"RTN","XU8P585",80,0)
DIR() ;get directory for printer queues, a subdirectory of host file directory
"RTN","XU8P585",81,0)
 N DIR,CODE
"RTN","XU8P585",82,0)
 S CODE=$$PRI^%ZOSV
"RTN","XU8P585",83,0)
 S DIR=$$CHKNM^%ZISF($P($G(^XTV(8989.3,1,"DEV")),"^",CODE))
"RTN","XU8P585",84,0)
 I $$OS^%ZOSV()["VMS" D
"RTN","XU8P585",85,0)
 .S DIR=$P(DIR,"]")_".print_queues]"
"RTN","XU8P585",86,0)
 E  D
"RTN","XU8P585",87,0)
 .S DIR=DIR_"print_queues/"
"RTN","XU8P585",88,0)
 Q DIR
"RTN","XU8P585",89,0)
 ;
"RTN","XU8P585",90,0)
FEXIST(FILE) ;
"RTN","XU8P585",91,0)
 ;returns 1 if the file exists, 0 otherwise
"RTN","XU8P585",92,0)
 ;
"RTN","XU8P585",93,0)
 N OS S OS=$$OS^%ZOSV()
"RTN","XU8P585",94,0)
 I OS["UNIX" Q $$LFEXIST(FILE)
"RTN","XU8P585",95,0)
 E  I OS["VMS" Q $$VFEXIST(FILE)
"RTN","XU8P585",96,0)
 Q 0
"RTN","XU8P585",97,0)
 ;
"RTN","XU8P585",98,0)
VFEXIST(FILE) ;
"RTN","XU8P585",99,0)
 ;checks file's existance - VMS
"RTN","XU8P585",100,0)
 N CMD,RET
"RTN","XU8P585",101,0)
 S CMD="PIPE F = F$SEARCH("""_FILE_""")"
"RTN","XU8P585",102,0)
 S CMD=CMD_" ; IF F$LENGTH(F) .EQ. 0 THEN DEFINE/JOB ZIS$VAL 0 ; IF F$LENGTH(F) .GT. 0 THEN DEFINE/JOB ZIS$VAL 1 "
"RTN","XU8P585",103,0)
 I $ZF(-1,CMD)
"RTN","XU8P585",104,0)
 S RET=$ZF("TRNLNM","ZIS$VAL","LNM$JOB")
"RTN","XU8P585",105,0)
 I $ZF(-1,"DEASSIGN/JOB ZIS$VAL")
"RTN","XU8P585",106,0)
 Q +$G(RET)
"RTN","XU8P585",107,0)
 ;
"RTN","XU8P585",108,0)
LFEXIST(FILE) ;
"RTN","XU8P585",109,0)
 ;checks file's existance - Linux,Unix
"RTN","XU8P585",110,0)
 N CMD
"RTN","XU8P585",111,0)
 S CMD="[ -f "_$$REPLACE(FILE,"$","'$'")_" ]"
"RTN","XU8P585",112,0)
 Q '$ZF(-1,CMD)
"RTN","XU8P585",113,0)
 ;
"RTN","XU8P585",114,0)
FDELETE(FILE) ;
"RTN","XU8P585",115,0)
 ;delete file
"RTN","XU8P585",116,0)
 N OS S OS=$$OS^%ZOSV()
"RTN","XU8P585",117,0)
 I OS["UNIX" D LFDELETE(FILE)
"RTN","XU8P585",118,0)
 E  I OS["VMS" D VFDELETE(FILE)
"RTN","XU8P585",119,0)
 Q
"RTN","XU8P585",120,0)
 ;
"RTN","XU8P585",121,0)
VFDELETE(FILE) ;
"RTN","XU8P585",122,0)
 ;delete file - VMS
"RTN","XU8P585",123,0)
 N CMD
"RTN","XU8P585",124,0)
 I FILE'[";" S FILE=FILE_";*"
"RTN","XU8P585",125,0)
 S CMD="DELETE "_FILE
"RTN","XU8P585",126,0)
 I $ZF(-1,CMD)
"RTN","XU8P585",127,0)
 ;
"RTN","XU8P585",128,0)
LFDELETE(FILE) ;
"RTN","XU8P585",129,0)
 ;delete file - Linux,Unix
"RTN","XU8P585",130,0)
 N CMD
"RTN","XU8P585",131,0)
 S CMD="rm -f "_$$REPLACE(FILE,"$","'$'")
"RTN","XU8P585",132,0)
 I $ZF(-1,CMD)
"RTN","XU8P585",133,0)
 ;
"RTN","XU8P585",134,0)
REPLACE(STRING,SUB1,SUB2) ;
"RTN","XU8P585",135,0)
 ;
"RTN","XU8P585",136,0)
 N REPLACE
"RTN","XU8P585",137,0)
 S REPLACE(SUB1)=SUB2
"RTN","XU8P585",138,0)
 Q $$REPLACE^XLFSTR(STRING,.REPLACE)
"RTN","XU8P585",139,0)
 ;
"RTN","XU8P585",140,0)
 ;
"RTN","XU8P585",141,0)
 ;
"RTN","XU8P585",142,0)
 ;
"RTN","ZIS2")
0^3^B19905647^B17503413
"RTN","ZIS2",1,0)
%ZIS2 ;SFISC/AC,RWF -- DEVICE HANDLER (CHECKS) ;11/08/2011
"RTN","ZIS2",2,0)
 ;;8.0;KERNEL;**69,104,112,118,136,241,440,546,585**;JUL 10, 1995;Build 22
"RTN","ZIS2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified
"RTN","ZIS2",4,0)
 ;
"RTN","ZIS2",5,0)
L2 ;Entry point from %ZIS1, %E holds the IEN value
"RTN","ZIS2",6,0)
 I $D(DTOUT)!$D(DUOUT) K %ZISHP,%ZISHPOP Q
"RTN","ZIS2",7,0)
CHECK ;Get IO check for secondary $I
"RTN","ZIS2",8,0)
 K %ZISCPU N %Z2,%ZFQ
"RTN","ZIS2",9,0)
 S POP=0,%Z=^%ZIS(1,%E,0),%Z2=$S(%ZIS("PRI")=1:"",1:$G(^%ZIS(1,%E,2))) ;Get Primary and secondary IO.
"RTN","ZIS2",10,0)
 S IO=$S(%ZIS("PRI")=1:$P(%Z,"^",2),$L($P(%Z2,"^")):$P(%Z2,"^"),1:$P(%Z,"^",2)) ;
"RTN","ZIS2",11,0)
 S %Z90=$G(^(90)),%Z95=$G(^(95)),%ZTIME=$G(^("TIME")),%ZTYPE=$G(^("TYPE"))
"RTN","ZIS2",12,0)
 I '$$QUECHK Q
"RTN","ZIS2",13,0)
 I %ZTYPE="RES" S %ZISRL=+$P(%Z1,"^",10) G T
"RTN","ZIS2",14,0)
VTRM I %ZTYPE="VTRM",'('$D(IO("Q"))&(%A=%H)) W:'$D(IOP)&'$D(%ZISHP) *7,"  [YOU CAN NOT SELECT A VIRTUAL TERMINAL]" S POP=1 ;Virtual Terminal Check
"RTN","ZIS2",15,0)
 S:%ZTYPE="VTRM"&'$D(IO("Q"))&(%A=%H) IO=$I
"RTN","ZIS2",16,0)
 ;
"RTN","ZIS2",17,0)
SLAVE I $D(IO("Q")),$P(%Z,"^",2)=0,$P(%Z,"^",8)']"" W:'$D(IOP) *7,!?10,"  [SLAVE device NOT set up for queuing]" S POP=1 G T
"RTN","ZIS2",18,0)
 ;
"RTN","ZIS2",19,0)
 ;
"RTN","ZIS2",20,0)
 ;**P585 START CJM
"RTN","ZIS2",21,0)
PQ ;Check (if not queueing to secondary system) that print queue is established and available
"RTN","ZIS2",22,0)
 I %ZTYPE="PQ",%ZISB!'$P($G(^XTV(8989.3,1,0)),"^",5),(%ZIS'["T"),'$$QEXIST^ZISPQ(%E) D  G T
"RTN","ZIS2",23,0)
 .S POP=1
"RTN","ZIS2",24,0)
 .W:'$D(IOP) *7,!?10,"  [The Print Queue does not exist]"
"RTN","ZIS2",25,0)
 ;**P585 END CJM
"RTN","ZIS2",26,0)
 ;
"RTN","ZIS2",27,0)
OCPU D OTHCPU("DEVICE")
"RTN","ZIS2",28,0)
 ;
"RTN","ZIS2",29,0)
OOS G T:POP
"RTN","ZIS2",30,0)
 ;Out Of Service Check
"RTN","ZIS2",31,0)
 I %Z90,$D(DT)#2,%Z90'>DT S POP=1 I '$D(IOP),'$D(%ZISHP) W *7,"  [Out of Service]"
"RTN","ZIS2",32,0)
 ;
"RTN","ZIS2",33,0)
PTIME G T:POP!(IO=$I)!(IO=0)
"RTN","ZIS2",34,0)
 ;Prohibitted Time Check
"RTN","ZIS2",35,0)
 S %A=$P(%ZTIME,"^") I %ZISB,$L(%A) D  I POP,'$D(IOP),'$D(%ZISHP) W *7,"  [ACCESS PROHIBITED "_%A_"]" ;AT THIS TIME]"
"RTN","ZIS2",36,0)
 . N %C,%L,%H ;%C is current time, %L is lower limit, %H is upper limit
"RTN","ZIS2",37,0)
 . S %C=$P($H,",",2),%C=%C\60#60+(%C\3600*100),%H=$P(%A,"-",2),%L=+%A
"RTN","ZIS2",38,0)
 . I $S(%H'<%L:(%C'>%H&(%C'<%L)),1:(%C'<%L!(%C'>%H))) S POP=1
"RTN","ZIS2",39,0)
 . Q
"RTN","ZIS2",40,0)
DUZ I 'POP D SEC ;Security Check
"RTN","ZIS2",41,0)
 ;
"RTN","ZIS2",42,0)
T ;
"RTN","ZIS2",43,0)
 ;
"RTN","ZIS2",44,0)
TMPVAR K IO("S") S %ZISIOS=%E S:IO=0 IO=$I,IO("S")=%H
"RTN","ZIS2",45,0)
 S %ZISOPAR=$$IOPAR(%E,"IOPAR")
"RTN","ZIS2",46,0)
 S %ZISUPAR=$$IOPAR(%E,"IOUPAR"),%ZISTO=+$P(%ZTIME,"^",2)
"RTN","ZIS2",47,0)
 ;Slave Device
"RTN","ZIS2",48,0)
 I $D(IO("S")) D  I POP Q
"RTN","ZIS2",49,0)
 . S IO=$S(%ZIS["S":$P($G(^%ZIS(1,+$P(%Z,"^",8),0)),"^",2),1:IO)
"RTN","ZIS2",50,0)
 . I %ZIS["S",IO]"" S %H=+$P(%Z,"^",8),IO("S")=%H,IO(0)=IO
"RTN","ZIS2",51,0)
 . S IO("S")=$S($G(^XUTL("XQ",$J,"IOST(0)")):^("IOST(0)"),1:$G(^%ZIS(1,%H,"SUBTYPE")))
"RTN","ZIS2",52,0)
 . S:IO="" POP=1
"RTN","ZIS2",53,0)
 . Q
"RTN","ZIS2",54,0)
 S %A=+$G(^%ZIS(1,%E,"SUBTYPE")),%ZISTP=0 ;%A is pointer to subtype
"RTN","ZIS2",55,0)
 I %E=%H,%ZTYPE["TRM" D  I 1
"RTN","ZIS2",56,0)
 . I $D(^XUTL("XQ",$J,"IOST(0)")) D  ;Use home
"RTN","ZIS2",57,0)
 . . S %A=+^XUTL("XQ",$J,"IOST(0)"),%Z91="",%ZISTP=1
"RTN","ZIS2",58,0)
 . . F %ZISI="IOM","IOF","IOSL","IOBS","IOXY" S %Z91=%Z91_$G(^XUTL("XQ",$J,%ZISI))_"^"
"RTN","ZIS2",59,0)
 . E  S %=$$LNPRTSUB^%ZISUTL I %>0 S %A=%,%Z91=""
"RTN","ZIS2",60,0)
 E  S %Z91=$P($G(^%ZIS(2,%A,1)),"^",1,4),$P(%Z91,"^",5)=$G(^("XY"))
"RTN","ZIS2",61,0)
 ;
"RTN","ZIS2",62,0)
 D ST^%ZIS3(%ZISTP) S:%ZIS["U" USIO=$P(%Z91,"^",1,4)
"RTN","ZIS2",63,0)
T2 I POP S:%ZIS'["T" IO="" Q
"RTN","ZIS2",64,0)
 ;Removed HG from next line.
"RTN","ZIS2",65,0)
 ;**P585 START CJM
"RTN","ZIS2",66,0)
 ;G ^%ZIS3:"^MTRM^VTRM^TRM^SPL^MT^SDP^HFS^RES^OTH^BAR^IMPC^CHAN^"[("^"_%ZTYPE_"^") ;Jump to next part
"RTN","ZIS2",67,0)
 G ^%ZIS3:"^MTRM^VTRM^TRM^SPL^MT^SDP^HFS^RES^OTH^BAR^IMPC^CHAN^PQ^"[("^"_%ZTYPE_"^") ;Jump to next part
"RTN","ZIS2",68,0)
 ;**P585 END CJM
"RTN","ZIS2",69,0)
 S POP=1 Q
"RTN","ZIS2",70,0)
 ;
"RTN","ZIS2",71,0)
QUECHK() ;Return 1 if OK
"RTN","ZIS2",72,0)
 S %ZFQ=$P(%Z,"^",12) ;5.5 =QUEUING 0:ALLOWED;1:FORCED;2:NOT ALLOWED;
"RTN","ZIS2",73,0)
 ;Forced Queuing, Don't check if %ZIS["N"
"RTN","ZIS2",74,0)
 S:%ZIS["Q"&'$D(ZTQUEUED)&(%ZFQ=1!$D(XQNOGO)) %ZISB=0,IO("Q")=1
"RTN","ZIS2",75,0)
 I %ZFQ=1,(%ZIS'["Q")&(%ZIS'["N"),'$D(ZTQUEUED) D  Q 0
"RTN","ZIS2",76,0)
 . W:'$D(IOP) !,"Sorry, QUEUING is required for this device."
"RTN","ZIS2",77,0)
 . S POP=1
"RTN","ZIS2",78,0)
 . Q
"RTN","ZIS2",79,0)
 ;Or Queuing NOT allowed
"RTN","ZIS2",80,0)
 I %ZFQ=2 S %ZIS=$TR(%ZIS,"Q") I $D(IO("Q")) D  Q 0
"RTN","ZIS2",81,0)
 . W:'$D(IOP) !,"Queuing NOT ALLOWED on this device"
"RTN","ZIS2",82,0)
 . S POP=1 K:$D(IOP) IO("Q")
"RTN","ZIS2",83,0)
 . Q
"RTN","ZIS2",84,0)
 Q 1
"RTN","ZIS2",85,0)
 ;
"RTN","ZIS2",86,0)
OTHCPU(%1) ;%1 should be either DEVICE or HUNT GROUP
"RTN","ZIS2",87,0)
 N %2,X,Y,%ZISMSG S %ZISMSG=0
"RTN","ZIS2",88,0)
 F %2="CPU","VOLUME SET" D
"RTN","ZIS2",89,0)
 .I %2="VOLUME SET" S X=$P($P(%Z,"^",9),":"),Y=%ZISV
"RTN","ZIS2",90,0)
 .E  D GETENV^%ZOSV S X=$P($P(%Z,"^",9),":",2),Y=$P($P(Y,"^",4),":",2)
"RTN","ZIS2",91,0)
 .I X=Y!(X="") Q:%1="DEVICE"  D  Q  ;Other Vol Set/Cpu Check
"RTN","ZIS2",92,0)
 ..S %ZISHG(0)=%E,%ZISHG=$P(%Z,"^")
"RTN","ZIS2",93,0)
 ..I %ZISB S POP=1
"RTN","ZIS2",94,0)
 ..E  S IO=" "
"RTN","ZIS2",95,0)
 .I %2="VOLUME SET" S $P(%ZISCPU,":")=X
"RTN","ZIS2",96,0)
 .E  S $P(%ZISCPU,":",2)=X
"RTN","ZIS2",97,0)
 .I %1="HUNT GROUP" K %ZISHG(0)
"RTN","ZIS2",98,0)
 .I %ZIS["Q" S IO("Q")=1,%ZISB=0 S:%1="HUNT GROUP" IO=" "
"RTN","ZIS2",99,0)
 .E  I %ZISB&(%ZTYPE="TRM"&($D(%ZISHG(0))&(%ZIS'["D"))) S POP=1
"RTN","ZIS2",100,0)
 .E  W:'$D(IOP)&'%ZISMSG *7,"  ["_%1_" is on another "_%2_" ('"_X_"')]",! S POP=1,%ZISMSG=1
"RTN","ZIS2",101,0)
 Q
"RTN","ZIS2",102,0)
IOPAR(%DA,%N) ;Return I/O parameter
"RTN","ZIS2",103,0)
 Q $S($L($G(%ZIS(%N))):%ZIS(%N),1:$G(^%ZIS(1,%DA,%N)))
"RTN","ZIS2",104,0)
 ;
"RTN","ZIS2",105,0)
SEC ;Do Security check
"RTN","ZIS2",106,0)
 I %Z95]"" S %X=$G(DUZ(0)) I %X'="@" S POP=1 F %A=1:1:$L(%X) I %Z95[$E(%X,%A) S POP=0 Q
"RTN","ZIS2",107,0)
 I POP,'$D(IOP),'$D(%ZISHP) W *7,"  [Access Prohibited]"
"RTN","ZIS2",108,0)
 Q
"RTN","ZIS2",109,0)
 ;
"RTN","ZIS2",110,0)
 ;
"RTN","ZIS2",111,0)
 ;
"RTN","ZIS2",112,0)
 ;
"RTN","ZIS2",113,0)
 ;
"RTN","ZIS6")
0^7^B21650565^B20915436
"RTN","ZIS6",1,0)
%ZIS6 ;SFISC/AC - DEVICE HANDLER -- RESOURCES ;10/14/2011
"RTN","ZIS6",2,0)
 ;;8.0;KERNEL;**24,49,69,118,127,136,440,546,585**;JUL 10, 1995;Build 22
"RTN","ZIS6",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified
"RTN","ZIS6",4,0)
 ;Expect that IO is current device
"RTN","ZIS6",5,0)
OXECUTE ;Open Execute
"RTN","ZIS6",6,0)
 I $D(^%ZIS(2,%ZISIOST(0),2))=1 S %Y=^(2) D 2
"RTN","ZIS6",7,0)
ANSBAK ;Answer Back
"RTN","ZIS6",8,0)
 I $D(^%ZIS(2,%ZISIOST(0),102)) S %Y=^(102) D 2 E  S POP=1 D:'$D(IOP) SAY($C(7)_"[NOT ON LINE]") C:%ZISB IO K IO(1,IO) G QUIT
"RTN","ZIS6",9,0)
 I $D(%ZISMTR) X ^%ZOSF("MAGTAPE") U IO W:$D(%MT("REW")) @%MT("REW") U IO(0) K %MT
"RTN","ZIS6",10,0)
 G QUIT:'$D(IO("P"))
"RTN","ZIS6",11,0)
 I $F(IO("P"),"B"),$D(^%ZIS(2,%ZISIOST(0),7)) S %Y=$P(^(7),"^",1) I %Y]"" W @%Y
"RTN","ZIS6",12,0)
 S %Y=$F(IO("P"),"P") G QLTY:'%Y S %Y=+$E(IO("P"),%Y,99),%X=$S(%Y=16:12.1,%Y=10!(%Y=12):5,1:"") G QLTY:'%X
"RTN","ZIS6",13,0)
 S %Y=$S($D(^%ZIS(2,%ZISIOST(0),%X)):$P(^(%X),"^",$S(%Y=12:2,1:1)),1:"")
"RTN","ZIS6",14,0)
 I %Y]"" W @%Y
"RTN","ZIS6",15,0)
QLTY S %Y=$F(IO("P"),"Q") Q:'%Y  S %Y=+$E(IO("P"),%Y,99),%X=$S(%Y<0!(%Y>2):0,1:%Y+1)
"RTN","ZIS6",16,0)
 I %X S %Y=$S($D(^%ZIS(2,%ZISIOST(0),12.2)):$P(^(12.2),"^",%X),1:"") I %Y]""  W @%Y
"RTN","ZIS6",17,0)
QUIT U:%ZIS'[0 IO(0)
"RTN","ZIS6",18,0)
 Q
"RTN","ZIS6",19,0)
2 ;Do Execute code
"RTN","ZIS6",20,0)
 Q:%Y=""  I %ZIS'[0,$D(^%ZIS(1,+%H,"TYPE")),^("TYPE")["TRM" D OH Q:POP
"RTN","ZIS6",21,0)
 S %X=$T U IO D %Y^ZISX
"RTN","ZIS6",22,0)
 Q
"RTN","ZIS6",23,0)
OH ;Open Home
"RTN","ZIS6",24,0)
 Q:$S($L($G(IO(0))):$D(IO(1,IO(0))),1:0)
"RTN","ZIS6",25,0)
 N $ES,$ET S $ET="G OPNERR^%ZIS4"
"RTN","ZIS6",26,0)
 O IO(0)::0 S IO(1,IO(0))="" ;See that HOME DEVICE is open.
"RTN","ZIS6",27,0)
 Q
"RTN","ZIS6",28,0)
 ;
"RTN","ZIS6",29,0)
SAY(%SAY) ;
"RTN","ZIS6",30,0)
 Q:%ZIS[0  U IO(0) W %SAY U IO
"RTN","ZIS6",31,0)
 Q
"RTN","ZIS6",32,0)
RES1 ;Allocate a resource slot, Release in %ZISC.
"RTN","ZIS6",33,0)
 N A,L,X,%ZISD0
"RTN","ZIS6",34,0)
 S %ZISD0=$O(^%ZISL(3.54,"B",IO,0))
"RTN","ZIS6",35,0)
 I '%ZISD0 S %ZISD0=$$RADD(IO) ;New one
"RTN","ZIS6",36,0)
 L +^%ZISL(3.54,%ZISD0,0):2 I '$T S POP=1 W:'$D(IOP) *7,"  [NOT Available]" G RESX
"RTN","ZIS6",37,0)
RES2 S X=$P(^%ZISL(3.54,%ZISD0,0),"^",2)
"RTN","ZIS6",38,0)
 I X<1 S POP=1 W:'$D(IOP) *7,"  [NOT Available]" G RESX
"RTN","ZIS6",39,0)
 S X=$S(X>0:X-1,1:0),$P(^%ZISL(3.54,%ZISD0,0),"^",2)=X
"RTN","ZIS6",40,0)
 ;
"RTN","ZIS6",41,0)
R1 ;Grab a slot
"RTN","ZIS6",42,0)
 S IO(1,IO)="RES",A=$G(^%ZISL(3.54,%ZISD0,1,0),"^3.542^^")
"RTN","ZIS6",43,0)
 F L=1:1:%ZISRL I '$D(^%ZISL(3.54,%ZISD0,1,L,0)) Q
"RTN","ZIS6",44,0)
 I '$T K IO(1,IO) G RES2 ;No free slots
"RTN","ZIS6",45,0)
 S ^%ZISL(3.54,%ZISD0,1,L,0)=L_"^"_%ZISV_"^"_$J_"^"_$G(ZTSK)_"^"_$H,^%ZISL(3.54,"AJ",$J,%ZISD0,L)="",^%ZISL(3.54,%ZISD0,1,"B",L,L)=""
"RTN","ZIS6",46,0)
 S $P(A,"^",3,4)=L_U_($P(A,U,4)+1),^%ZISL(3.54,%ZISD0,1,0)=A
"RTN","ZIS6",47,0)
RESX L -^%ZISL(3.54,%ZISD0,0) Q
"RTN","ZIS6",48,0)
 ;
"RTN","ZIS6",49,0)
RADD(X) ;Add Resource
"RTN","ZIS6",50,0)
 N %1,%2
"RTN","ZIS6",51,0)
 S %1=$G(^%ZISL(3.54,0),"RESOURCE^3.54^^"),%2=$P(%1,U,3)
"RTN","ZIS6",52,0)
 F %2=%2:1 Q:'$D(^%ZISL(3.54,%2,0))
"RTN","ZIS6",53,0)
 S $P(^%ZISL(3.54,0),U,3,4)=%2_U_($P(%1,U,4)+1),^%ZISL(3.54,%2,0)=X_"^"_$G(%ZISRL,1),^%ZISL(3.54,"B",X,%2)=""
"RTN","ZIS6",54,0)
 Q %2
"RTN","ZIS6",55,0)
 ;
"RTN","ZIS6",56,0)
RESOK ;DEVOK check for RES devices, for all OS's.
"RTN","ZIS6",57,0)
 N %ZISD0,%ZISD1
"RTN","ZIS6",58,0)
 S Y=0,%ZISD0=$O(^%ZISL(3.54,"B",X,0))
"RTN","ZIS6",59,0)
 I '%ZISD0 S Y=-1,%ZISD0=$O(^%ZIS(1,"C",X,0)) Q:'%ZISD0  Q:'$D(^%ZIS(1,+%ZISD0,0))  Q:$P(^(0),"^")'=X  Q:'$D(^("TYPE"))  Q:^("TYPE")'="RES"  S Y=0 Q
"RTN","ZIS6",60,0)
 S X1=$G(^%ZISL(3.54,+%ZISD0,0))
"RTN","ZIS6",61,0)
 I $P(X1,"^",2)&(X=$P(X1,"^")) S Y=0 Q
"RTN","ZIS6",62,0)
 S Y=999 F %ZISD1=0:0 S %ZISD1=$O(^%ZISL(3.54,%ZISD0,1,%ZISD1)) Q:%ZISD1'>0  I $D(^(%ZISD1,0)) S Y=$P(^(0),"^",3) Q
"RTN","ZIS6",63,0)
 Q
"RTN","ZIS6",64,0)
 ;
"RTN","ZIS6",65,0)
Q G Q^%ZIS3
"RTN","ZIS6",66,0)
HG ;Was Hunt Group
"RTN","ZIS6",67,0)
 Q
"RTN","ZIS6",68,0)
SPL ;Spool type
"RTN","ZIS6",69,0)
 N %E,%Z D MARGN^%ZIS3 W:'$D(IOP) ! D SPOOL^%ZIS4:%ZIS'["T"
"RTN","ZIS6",70,0)
 G Q
"RTN","ZIS6",71,0)
MT D MARGN^%ZIS3,ASKPAR,AMTREW:'POP&'$D(IOP)&%ZISB W:'$D(IOP) ! D O^%ZIS4:'POP&(%ZISB&(%ZIS'["T")) ;Magtape type
"RTN","ZIS6",72,0)
 G Q
"RTN","ZIS6",73,0)
SDP ;Sequential disk processor type
"RTN","ZIS6",74,0)
 D MARGN^%ZIS3,ASKPAR W:'$D(IOP) ! D O^%ZIS4:'POP&(%ZISB&(%ZIS'["T"))
"RTN","ZIS6",75,0)
 G Q
"RTN","ZIS6",76,0)
HFS ;Host File Server type
"RTN","ZIS6",77,0)
 D MARGN^%ZIS3,HFS^%ZISF W:'$D(IOP) ! D O^%ZIS4:'POP&(%ZISB&(%ZIS'["T"))
"RTN","ZIS6",78,0)
 G Q
"RTN","ZIS6",79,0)
 ;
"RTN","ZIS6",80,0)
 ;**P585 START CJM
"RTN","ZIS6",81,0)
PQ ;Print Queue type
"RTN","ZIS6",82,0)
 D MARGN^%ZIS3,OPEN^ZISPQ
"RTN","ZIS6",83,0)
 G Q^%ZIS3
"RTN","ZIS6",84,0)
 Q
"RTN","ZIS6",85,0)
 ;**585 END CJM
"RTN","ZIS6",86,0)
 ;
"RTN","ZIS6",87,0)
RES ;Resources
"RTN","ZIS6",88,0)
 G Q:%ZIS["T" N X,X1 I %ZIS'["R"!'$D(IOP) S POP=1 W:'$D(IOP) *7,"  [NOT AVAILABLE]" Q
"RTN","ZIS6",89,0)
 G Q:$D(IO(1,IO)) I %ZIS["T" S X=IO,X1="RES" D DEVOK^%ZIS3 S:Y POP=1 G Q:POP
"RTN","ZIS6",90,0)
 D:%ZISB RES1 G Q
"RTN","ZIS6",91,0)
CHAN ;Network Channel type devices -- DecNet or TCP/IP devices.
"RTN","ZIS6",92,0)
 I IO="SYS$NET",$I="SYS$INPUT:;" S IO(0)=IO U IO ;DECNET Server Device
"RTN","ZIS6",93,0)
 D MARGN^%ZIS3:'POP,ASKPAR:'POP W:'$D(IOP) ! D O^%ZIS4:'POP&(%ZISB&(%ZIS'["T"))
"RTN","ZIS6",94,0)
 G Q
"RTN","ZIS6",95,0)
IMPC ;Imaging Work Station
"RTN","ZIS6",96,0)
BAR ;Bar Code
"RTN","ZIS6",97,0)
OTH ;Other Device type
"RTN","ZIS6",98,0)
 D MARGN^%ZIS3:'POP,ASKPAR:'POP W:'$D(IOP) ! D O^%ZIS4:'POP&(%ZISB&(%ZIS'["T"))
"RTN","ZIS6",99,0)
 G Q
"RTN","ZIS6",100,0)
 ;
"RTN","ZIS6",101,0)
ASKPAR ;Ask Parameters
"RTN","ZIS6",102,0)
 G SETPAR^%ZIS3:$D(IOP),SETPAR^%ZIS3:'$P(^%ZIS(1,%E,0),"^",4) W "  ADDRESS/PARAMETERS: " W:%ZISOPAR]"" %ZISOPAR_"// " D SBR^%ZIS1 D MSG1:%X="?" G ASKPAR:%X="?" S:%X]"" %ZISOPAR=%X I $D(DTOUT)!$D(DUOUT) S POP=1
"RTN","ZIS6",103,0)
 I POP,%ZISB&(%ZTYPE["TRM") C IO K IO(1,IO) Q
"RTN","ZIS6",104,0)
 Q:POP  G SETPAR^%ZIS3
"RTN","ZIS6",105,0)
 ;
"RTN","ZIS6",106,0)
AMTREW ;Mag Tape Rewind
"RTN","ZIS6",107,0)
 I %ZISB,%ZTYPE="MT",'$D(IOP) W "  REWIND" S %=2,U="^",%ZISDTIM=60 D YN^%ZIS1 K %ZISDTIM G AMTREW:%=0 I %=-1 S POP=1 Q
"RTN","ZIS6",108,0)
 S:%=1 %ZISMTR=1
"RTN","ZIS6",109,0)
 Q
"RTN","ZIS6",110,0)
MSG1 W !?5,"Enter the desired parameters needed to open the selected device.",!?25
"RTN","ZIS6",111,0)
 Q
"RTN","ZIS6",112,0)
 ;
"RTN","ZISC")
0^6^B23112618^B22332594
"RTN","ZISC",1,0)
%ZISC ;SFISC/GFT,AC,MUS - CLOSE LOGIC FOR DEVICES  ;11/08/2011
"RTN","ZISC",2,0)
 ;;8.0;KERNEL;**24,36,49,69,199,216,275,409,440,585**;JUL 10, 1995;Build 22
"RTN","ZISC",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified
"RTN","ZISC",4,0)
C0 ;
"RTN","ZISC",5,0)
 N %,%E,%H,%ZISI,%ZISOS,%ZISX,%ZISV
"RTN","ZISC",6,0)
 ;Clear IO var we will use for reporting
"RTN","ZISC",7,0)
 K IO("ERROR"),IO("LASTERR"),IO("CLOSE")
"RTN","ZISC",8,0)
 ;Protect ourself from calls with incomplete setup.
"RTN","ZISC",9,0)
 S:$D(IO)[0 IO=$I S:'$D(IO(0)) IO(0)=$P
"RTN","ZISC",10,0)
 S U="^",%ZISOS=$G(^%ZOSF("OS")),%ZISV=$G(^("VOL"))
"RTN","ZISC",11,0)
 ;S %=$S(+$G(IOS):IOS,$L($G(ION)):ION,1:IO)
"RTN","ZISC",12,0)
 S %=$S($L($G(ION)):ION,1:IO) ;p409
"RTN","ZISC",13,0)
 I (%="")!(IO="") G SETIO:IO(0)]"",END
"RTN","ZISC",14,0)
 I $G(IOT)="RES" D RES G SETIO ;Handle a resource device
"RTN","ZISC",15,0)
 ;
"RTN","ZISC",16,0)
 ;Define subtype info if not already defined.
"RTN","ZISC",17,0)
 D SUBTYPE
"RTN","ZISC",18,0)
 ;
"RTN","ZISC",19,0)
 ;perform close execute
"RTN","ZISC",20,0)
 I $G(IOST(0))>0 D
"RTN","ZISC",21,0)
 . I $G(^%ZIS(2,+IOST(0),3))]"",$D(IO(1,IO)) D
"RTN","ZISC",22,0)
 . . U IO S:$X $X=1 D X3^ZISX:'$D(IO("T"))
"RTN","ZISC",23,0)
 ;
"RTN","ZISC",24,0)
 ;Incase the Close execute changed IO, Open IO("HOME") or NULL.
"RTN","ZISC",25,0)
 I '$L($G(IO)) D  Q
"RTN","ZISC",26,0)
 . S IOP=$S($L($G(IO("HOME"))):"`"_(+IO("HOME")),1:"NULL") D ^%ZIS
"RTN","ZISC",27,0)
 . Q
"RTN","ZISC",28,0)
 ;
"RTN","ZISC",29,0)
 ;Perform the following if the device is open.
"RTN","ZISC",30,0)
 I $D(IO(1,IO)) D
"RTN","ZISC",31,0)
 . I $G(IO("P"))["B" D  ;Return to normal intensity
"RTN","ZISC",32,0)
 . . S %=$P($G(^%ZIS(2,+IOST(0),7)),"^",3) I %]"" W @%
"RTN","ZISC",33,0)
 . I $G(IO("P"))["P" D  ;Return to default pitch
"RTN","ZISC",34,0)
 . . S %=$G(^%ZIS(2,+IOST(0),12.11)) I %]"" W @%
"RTN","ZISC",35,0)
 . ;
"RTN","ZISC",36,0)
 . W:$$FF @IOF ;Issue form feed at close
"RTN","ZISC",37,0)
 . I $$CLOSPP D X11^ZISX:'$D(IO("T")) K IO("S") ;Close printer port
"RTN","ZISC",38,0)
 . Q
"RTN","ZISC",39,0)
 ;
"RTN","ZISC",40,0)
 ;Don't use IOCPU as we now use IO(1,IO)
"RTN","ZISC",41,0)
 I (IO'=IO(0)!$D(IO("C"))),$D(IO(1,IO)) D
"RTN","ZISC",42,0)
 . U:$S($D(ZTQUEUED):0,'$L($G(IO(0))):0,$D(IO(1,IO(0)))#2:1,1:0) IO(0)
"RTN","ZISC",43,0)
 . C IO K IO(1,IO) S IO("CLOSE")=IO ;close device`
"RTN","ZISC",44,0)
 ;Unlock global used to control access.
"RTN","ZISC",45,0)
 S %=$G(^XUTL("XQ",$J,"lock",+$G(IOS))) I $L(%) L -@% K ^XUTL("XQ",$J,"lock",IOS)
"RTN","ZISC",46,0)
 ;
"RTN","ZISC",47,0)
 ;**P585 START CJM
"RTN","ZISC",48,0)
 I $G(IOT)="PQ" D CLOSE^ZISPQ(IO)
"RTN","ZISC",49,0)
 ;**P585 END CJM
"RTN","ZISC",50,0)
 ;
"RTN","ZISC",51,0)
 I $D(IO("SPOOL")) D CLOSE^%ZIS4 ;Special close for spool device
"RTN","ZISC",52,0)
 ;
"RTN","ZISC",53,0)
SETIO ;
"RTN","ZISC",54,0)
 ;See if old device has PCX code
"RTN","ZISC",55,0)
 I $G(IOS),$G(^%ZIS(1,+IOS,"PCX"))]"" S %ZISPCX=^("PCX")
"RTN","ZISC",56,0)
 ;Setup the IO(0) device, should be the home device
"RTN","ZISC",57,0)
 S IO=IO(0),(IOPAR,IOUPAR)="" K IO("T") D CIOS(IO(0))
"RTN","ZISC",58,0)
 I 'IOS S IOT="TRM" G END
"RTN","ZISC",59,0)
 S ION=$P(^%ZIS(1,IOS,0),"^",1),IOT=$G(^("TYPE")),IOST(0)=$S(IOT["TRM"&($D(^XUTL("XQ",$J,"IOST(0)"))):^("IOST(0)"),1:$G(^%ZIS(1,IOS,"SUBTYPE")))
"RTN","ZISC",60,0)
 I IOT["TRM",$D(^XUTL("XQ",$J,"IO")) D HOME^%ZIS G END
"RTN","ZISC",61,0)
 S %="Y"
"RTN","ZISC",62,0)
 I IOST(0),$D(^%ZIS(2,IOST(0),1)) S %=^(1),IOM=+%,IOF=$P(%,"^",2),IOSL=$P(%,"^",3),IOBS=$P(%,"^",4)
"RTN","ZISC",63,0)
 I $D(^%ZIS(1,IOS,91)) S %=^%ZIS(1,IOS,91) S:+% IOM=+% S:$P(%,"^",3) IOSL=$P(%,"^",3)
"RTN","ZISC",64,0)
 ;Don't know the subtype so set some defaults
"RTN","ZISC",65,0)
 I %="Y" S IOM=80,IOSL=24,IOF="#",IOST="C-OTHER",IOBS="$C(8)"
"RTN","ZISC",66,0)
S1 S:IOST(0) IOST=$P($G(^%ZIS(2,+IOST(0),0)),"^"),IOXY=$G(^("XY"))
"RTN","ZISC",67,0)
 I '$D(ZTQUEUED),'$D(IO("C")),IOT["TRM" D RM:$D(IO(1,IO))
"RTN","ZISC",68,0)
 ;With home device set, Do Post-close execute code of Device closed.
"RTN","ZISC",69,0)
END I '$D(IO("T")),$G(%ZISPCX)]"" S %Y=%ZISPCX D %Y^ZISX
"RTN","ZISC",70,0)
 ;See that any extra IO variables are cleaned up
"RTN","ZISC",71,0)
 K IO("P"),IO("DOC"),IO("HFSIO"),IO("SPOOL"),IOC,IONOFF
"RTN","ZISC",72,0)
 ;IOCPU should not be changed.
"RTN","ZISC",73,0)
 Q
"RTN","ZISC",74,0)
 ;
"RTN","ZISC",75,0)
SUBTYPE ;Find a subtype
"RTN","ZISC",76,0)
 N %S
"RTN","ZISC",77,0)
 S IOST=$G(IOST),IOST(0)=+$G(IOST(0))
"RTN","ZISC",78,0)
 I $L(IOST)&$L(IOST(0)) Q  ;Have a subtype
"RTN","ZISC",79,0)
 S %S=$G(^%ZIS(2,+IOST(0),0)) I $L(%S) S IOST=$P(%S,U) Q
"RTN","ZISC",80,0)
 I $L(IOST) S %S=$O(^%ZIS(2,"B",$G(IOST,"X"),0)) I %S>0 S IOST(0)=+%S Q
"RTN","ZISC",81,0)
 S IOST="",IOST(0)=0 D CIOS($I) Q:IOS'>0
"RTN","ZISC",82,0)
 S IOST(0)=$G(^%ZIS(1,+IOS,"SUBTYPE")),IOST=$P($G(^%ZIS(2,+IOST(0),0)),"^")
"RTN","ZISC",83,0)
 Q
"RTN","ZISC",84,0)
 ;
"RTN","ZISC",85,0)
CIOS(%I) ;Find a value for IOS (IEN into device file)
"RTN","ZISC",86,0)
 N %ZISVT
"RTN","ZISC",87,0)
 I $D(^XUTL("XQ",$J,"IOS")) S IOS=+^("IOS") Q
"RTN","ZISC",88,0)
 I $D(%ZISV) S %ZISVT=%I D VTLKUP^%ZIS S IOS=+%E
"RTN","ZISC",89,0)
 E  S IOS=+$O(^%ZIS(1,"C",%I,0))
"RTN","ZISC",90,0)
 Q:$G(IOS)>0
"RTN","ZISC",91,0)
 S %ZISVT=%I D VIRTUAL^%ZIS
"RTN","ZISC",92,0)
 I $D(%ZISVT) S %H=%E I %ZISVT]"",%H>0,$D(^%ZIS(1,%H,0)),$D(^("TYPE")),^("TYPE")="VTRM" S IOS=%H
"RTN","ZISC",93,0)
 Q
"RTN","ZISC",94,0)
 ;
"RTN","ZISC",95,0)
RM N X S X=+IOM X ^%ZOSF("RM")
"RTN","ZISC",96,0)
 Q
"RTN","ZISC",97,0)
 ;
"RTN","ZISC",98,0)
RES ;Close resource device.
"RTN","ZISC",99,0)
 Q:'$D(IO(1,IO))&'$D(^%ZISL(3.54,"AJ",$J))
"RTN","ZISC",100,0)
 N %ZISJOB,%X,%Y,%ZISD0,%ZISD1,%ZISRES,%ZISRL,%ZISY0,%ZTRTN,ZTSAVE,ZTIO
"RTN","ZISC",101,0)
 S %ZISJOB=$J
"RTN","ZISC",102,0)
 ;
"RTN","ZISC",103,0)
RES1 G RQ:'$D(IOS),RQ:'$D(^%ZIS(1,+IOS,1)) S %ZISRL=+$P(^(1),"^",10),%ZISRL=$S(%ZISRL:%ZISRL,1:1)
"RTN","ZISC",104,0)
 S %X=$O(^%ZISL(3.54,"B",IO,0)) G RQ:'%X
"RTN","ZISC",105,0)
 G RQ:'$D(^%ZISL(3.54,+%X,0)) S %ZISD0=+%X,%ZISY0=^(0)
"RTN","ZISC",106,0)
 S %X=$O(^%ZISL(3.54,"AJ",%ZISJOB,%ZISD0,0)) S %ZISD1=%X G RQ:'%X
"RTN","ZISC",107,0)
 S %Y=$G(^%ZISL(3.54,%ZISD0,1,+%ZISD1,0)) G RQ:$P(%Y,"^",3)'=%ZISJOB
"RTN","ZISC",108,0)
 D KILLRES(+%ZISD0,+%ZISD1)
"RTN","ZISC",109,0)
RQ K IO(1,IO)
"RTN","ZISC",110,0)
 Q
"RTN","ZISC",111,0)
 ;
"RTN","ZISC",112,0)
KILLRES(D0,D1) ;Kill one resource use
"RTN","ZISC",113,0)
 Q:(D0'>0)!(D1'>0)
"RTN","ZISC",114,0)
 N %X,%Y,%J,%ZISRL
"RTN","ZISC",115,0)
 L +^%ZISL(3.54,D0,0)
"RTN","ZISC",116,0)
 S %Y=$G(^%ZISL(3.54,D0,0)) G KRX:%Y=""
"RTN","ZISC",117,0)
 S %X=$G(^%ZISL(3.54,D0,1,D1,0)),%J=$P(%X,"^",3) S:%J="" %J=" "
"RTN","ZISC",118,0)
 K ^%ZISL(3.54,D0,1,D1,0),^%ZISL(3.54,D0,1,"B",D1,D1),^%ZISL(3.54,"AJ",%J,D0,D1)
"RTN","ZISC",119,0)
 S %X=$P(%Y,"^",2)+1,$P(^%ZISL(3.54,D0,0),"^",2)=%X
"RTN","ZISC",120,0)
 ;I '$D(^%ZISL(3.54,%ZISD0,1,0)) S ^(0)="^3.542A^^" G RQ
"RTN","ZISC",121,0)
 S %Y=$G(^%ZISL(3.54,D0,1,0)),%X=$P(%Y,"^",4),$P(^%ZISL(3.54,D0,1,0),"^",3,4)="^"_$S(%X>0:(%X-1),1:0)
"RTN","ZISC",122,0)
KRX L -^%ZISL(3.54,D0,0)
"RTN","ZISC",123,0)
 Q
"RTN","ZISC",124,0)
 ;
"RTN","ZISC",125,0)
DQCRES ;Tasked entry point to close resource device.
"RTN","ZISC",126,0)
 S IO=%ZISRES G RES1
"RTN","ZISC",127,0)
 ;
"RTN","ZISC",128,0)
FF() ;Issue form feed
"RTN","ZISC",129,0)
 I $E(IOST,1,2)'["C-",$D(IO(1,IO)),$G(IOT)="TRM"!($G(IOT)="SPL"),'$D(IO("T"))&$Y&'$D(IONOFF)&'$D(IO(1,IO,"NOFF")) Q 1
"RTN","ZISC",130,0)
 Q 0
"RTN","ZISC",131,0)
 ;
"RTN","ZISC",132,0)
CLOSPP() ;Close printer port
"RTN","ZISC",133,0)
 I $D(IO("S")),$D(^%ZIS(2,+IO("S"),11))&$D(IO(1,IO)) Q 1
"RTN","ZISC",134,0)
 Q 0
"RTN","ZISC",135,0)
 ;
"RTN","ZISC",136,0)
 ;
"RTN","ZISC",137,0)
 ;
"RTN","ZISC",138,0)
 ;
"RTN","ZISC",139,0)
 ;
"RTN","ZISC",140,0)
 ;
"RTN","ZISC",141,0)
 ;
"RTN","ZISC",142,0)
 ;
"RTN","ZISEDIT")
0^4^B2972844^B2624513
"RTN","ZISEDIT",1,0)
ZISEDIT ;ISF/AC - DEVICE EDIT ;10/26/2011
"RTN","ZISEDIT",2,0)
 ;;8.0;KERNEL;**440,585**;Jul 10, 1995;Build 22
"RTN","ZISEDIT",3,0)
 ;
"RTN","ZISEDIT",4,0)
TRM ;TRM or VTRM
"RTN","ZISEDIT",5,0)
 D EDIT("TRM",,"Select Terminal/Printer Device: ")
"RTN","ZISEDIT",6,0)
 Q
"RTN","ZISEDIT",7,0)
 ;
"RTN","ZISEDIT",8,0)
LPD ;LPD fields of a TRM device
"RTN","ZISEDIT",9,0)
 D EDIT("LPD","TRM","Select LPD (Terminal/Printer) Device: ")
"RTN","ZISEDIT",10,0)
 Q
"RTN","ZISEDIT",11,0)
 ;
"RTN","ZISEDIT",12,0)
MT ;Mag Tape
"RTN","ZISEDIT",13,0)
 D EDIT("MT",,"Select Magtape Device: ")
"RTN","ZISEDIT",14,0)
 Q
"RTN","ZISEDIT",15,0)
 ;
"RTN","ZISEDIT",16,0)
SDP ;
"RTN","ZISEDIT",17,0)
 D EDIT("SDP",,"Select SDP Device: ")
"RTN","ZISEDIT",18,0)
 Q
"RTN","ZISEDIT",19,0)
 ;
"RTN","ZISEDIT",20,0)
SPL ;Spool
"RTN","ZISEDIT",21,0)
 D EDIT("SPL",,"Select Spool Device: ")
"RTN","ZISEDIT",22,0)
 Q
"RTN","ZISEDIT",23,0)
 ;
"RTN","ZISEDIT",24,0)
HFS ;Host file
"RTN","ZISEDIT",25,0)
 D EDIT("HFS",,"Select Host File Device: ")
"RTN","ZISEDIT",26,0)
 Q
"RTN","ZISEDIT",27,0)
 ;**P 585 START CJM
"RTN","ZISEDIT",28,0)
PQ ;Print Queue
"RTN","ZISEDIT",29,0)
 D EDIT("PQ","PQ","Select Print Queue Device: ")
"RTN","ZISEDIT",30,0)
 Q
"RTN","ZISEDIT",31,0)
 ;**P 585 END CJM
"RTN","ZISEDIT",32,0)
 ;
"RTN","ZISEDIT",33,0)
CHAN ;Network
"RTN","ZISEDIT",34,0)
 D EDIT("CHAN",,"Select Network Channel: ")
"RTN","ZISEDIT",35,0)
 Q
"RTN","ZISEDIT",36,0)
 ;
"RTN","ZISEDIT",37,0)
RES ;Resource
"RTN","ZISEDIT",38,0)
 D EDIT("RES",,"Select Resource Device: ")
"RTN","ZISEDIT",39,0)
 Q
"RTN","ZISEDIT",40,0)
 ;
"RTN","ZISEDIT",41,0)
EDIT(ZISTYPE,ZISSCR,DICA) ;
"RTN","ZISEDIT",42,0)
 N Y,DA,DIC,DIE,DR,DDSFILE
"RTN","ZISEDIT",43,0)
ED2 S DIC("A")=DICA,ZISSCR=$G(ZISSCR,ZISTYPE)
"RTN","ZISEDIT",44,0)
 S DIC=3.5,DIC(0)="AEMQZL",DIC("S")="I $G(^(""TYPE""))["_""""_ZISSCR_"""" D ^DIC
"RTN","ZISEDIT",45,0)
 Q:Y'>0
"RTN","ZISEDIT",46,0)
 S DA=+Y
"RTN","ZISEDIT",47,0)
 I $P(Y,"^",3) D
"RTN","ZISEDIT",48,0)
 . N DIE,DR
"RTN","ZISEDIT",49,0)
 . S DIE=DIC,DR="2///"_ZISTYPE_$S(ZISTYPE["TRM":"",1:";1.95///N")
"RTN","ZISEDIT",50,0)
 . D ^DIE
"RTN","ZISEDIT",51,0)
 . Q
"RTN","ZISEDIT",52,0)
 S DR="[XUDEVICE "_ZISTYPE_"]",DDSFILE=3.5 D ^DDS
"RTN","ZISEDIT",53,0)
 G ED2
"RTN","ZISEDIT",54,0)
 Q
"RTN","ZISEDIT",55,0)
 ;
"RTN","ZISEDIT",56,0)
 ;
"RTN","ZISEDIT",57,0)
 ;
"RTN","ZISEDIT",58,0)
 ;
"RTN","ZISEDIT",59,0)
 ;
"RTN","ZISEDIT",60,0)
 ;
"RTN","ZISEDIT",61,0)
 ;
"RTN","ZISEDIT",62,0)
 ;
"RTN","ZISEDIT",63,0)
 ;
"RTN","ZISFM")
0^5^B3818871^n/a
"RTN","ZISFM",1,0)
ZISFM ;IRMFO-ALB/CJM - DEVICE HANDLER ;10/25/2011
"RTN","ZISFM",2,0)
 ;;8.0;KERNEL;**585**;JUL 10, 9;Build 22
"RTN","ZISFM",3,0)
 ;Per VHA Directive 10-93-142, this routine should not be modified.
"RTN","ZISFM",4,0)
 ;
"RTN","ZISFM",5,0)
UPD(FILE,DA,DATA,ERROR) ;File data into an existing record.
"RTN","ZISFM",6,0)
 ; Input:
"RTN","ZISFM",7,0)
 ;   FILE - File or sub-file number
"RTN","ZISFM",8,0)
 ;   DA - Traditional DA array, with same meaning.
"RTN","ZISFM",9,0)
 ;            Pass by reference.
"RTN","ZISFM",10,0)
 ;   DATA - Data array to file (pass by reference)
"RTN","ZISFM",11,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","ZISFM",12,0)
 ;
"RTN","ZISFM",13,0)
 ; Output:
"RTN","ZISFM",14,0)
 ;  Function Value -     0=error and 1=no error
"RTN","ZISFM",15,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","ZISFM",16,0)
 ;
"RTN","ZISFM",17,0)
 ; Example: To update a record in subfile 2.0361 in record with ien=353,
"RTN","ZISFM",18,0)
 ;          subrecord ien=68, with the field .01 value = 21:
"RTN","ZISFM",19,0)
 ;    S DATA(.01)=21,DA=68,DA(1)=353 I $$UPD(2.0361,.DA,.DATA,.ERROR) W !,"DONE"
"RTN","ZISFM",20,0)
 ;
"RTN","ZISFM",21,0)
 N FDA,FIELD,IENS,ERRORS
"RTN","ZISFM",22,0)
 ;
"RTN","ZISFM",23,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","ZISFM",24,0)
 ;FDA - the FDA array as defined by FM
"RTN","ZISFM",25,0)
 ;
"RTN","ZISFM",26,0)
 I '$G(DA) S ERROR="IEN OF RECORD TO BE UPDATED NOT SPECIFIED" Q 0
"RTN","ZISFM",27,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","ZISFM",28,0)
 S FIELD=0
"RTN","ZISFM",29,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","ZISFM",30,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","ZISFM",31,0)
 D FILE^DIE("","FDA","ERRORS(1)")
"RTN","ZISFM",32,0)
 I +$G(DIERR) D
"RTN","ZISFM",33,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","ZISFM",34,0)
 E  D
"RTN","ZISFM",35,0)
 .S ERROR=""
"RTN","ZISFM",36,0)
 ;
"RTN","ZISFM",37,0)
 D CLEAN^DILF
"RTN","ZISFM",38,0)
 Q $S(+$G(DIERR):0,1:1)
"RTN","ZISFM",39,0)
 ;
"RTN","ZISFM",40,0)
ADD(FILE,DA,DATA,ERROR,IEN) ;
"RTN","ZISFM",41,0)
 ;Description: Creates a new record and files the data.
"RTN","ZISFM",42,0)
 ; Input:
"RTN","ZISFM",43,0)
 ;   FILE - File or sub-file number
"RTN","ZISFM",44,0)
 ;   DA - Traditional FileMan DA array with same
"RTN","ZISFM",45,0)
 ;            meaning. Pass by reference.  Only needed if adding to a
"RTN","ZISFM",46,0)
 ;            subfile.
"RTN","ZISFM",47,0)
 ;   DATA - Data array to file, pass by reference
"RTN","ZISFM",48,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","ZISFM",49,0)
 ;   IEN - internal entry number to use (optional)
"RTN","ZISFM",50,0)
 ;
"RTN","ZISFM",51,0)
 ; Output:
"RTN","ZISFM",52,0)
 ;   Function Value - If no error then it returns the ien of the created record, else returns NULL.
"RTN","ZISFM",53,0)
 ;  DA - returns the ien of the new record, NULL if none created.  If needed, pass by reference.
"RTN","ZISFM",54,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","ZISFM",55,0)
 ;
"RTN","ZISFM",56,0)
 ; Example: To add a record in subfile 2.0361 in the record with ien=353
"RTN","ZISFM",57,0)
 ;          with the field .01 value = 21:
"RTN","ZISFM",58,0)
 ;  S DATA(.01)=21,DA(1)=353 I $$ADD(2.0361,.DA,.DATA) W !,"DONE"
"RTN","ZISFM",59,0)
 ;
"RTN","ZISFM",60,0)
 ; Example: If creating a record not in a subfile, would look like this:
"RTN","ZISFM",61,0)
 ;          S DATA(.01)=21 I $$ADD(867,,.DATA) W !,"DONE"
"RTN","ZISFM",62,0)
 ;
"RTN","ZISFM",63,0)
 N FDA,FIELD,IENA,IENS,ERRORS
"RTN","ZISFM",64,0)
 ;
"RTN","ZISFM",65,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","ZISFM",66,0)
 ;IENA - the Internal Entry Number Array defined by FM
"RTN","ZISFM",67,0)
 ;FDA - the FDA array defined by FM
"RTN","ZISFM",68,0)
 ;IEN - the ien of the new record
"RTN","ZISFM",69,0)
 ;
"RTN","ZISFM",70,0)
 S DA="+1"
"RTN","ZISFM",71,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","ZISFM",72,0)
 S FIELD=0
"RTN","ZISFM",73,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","ZISFM",74,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","ZISFM",75,0)
 I $G(IEN) S IENA(1)=IEN
"RTN","ZISFM",76,0)
 D UPDATE^DIE("","FDA","IENA","ERRORS(1)")
"RTN","ZISFM",77,0)
 I +$G(DIERR) D
"RTN","ZISFM",78,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","ZISFM",79,0)
 .S IEN=""
"RTN","ZISFM",80,0)
 E  D
"RTN","ZISFM",81,0)
 .S IEN=IENA(1)
"RTN","ZISFM",82,0)
 .S ERROR=""
"RTN","ZISFM",83,0)
 D CLEAN^DILF
"RTN","ZISFM",84,0)
 S DA=IEN
"RTN","ZISFM",85,0)
 Q IEN
"RTN","ZISFM",86,0)
 ;
"RTN","ZISFM",87,0)
DELETE(FILE,DA,ERROR)   ;Delete an existing record.
"RTN","ZISFM",88,0)
 N DATA
"RTN","ZISFM",89,0)
 S DATA(.01)="@"
"RTN","ZISFM",90,0)
 Q $$UPD(FILE,.DA,.DATA,.ERROR)
"RTN","ZISFM",91,0)
 Q
"RTN","ZISFM",92,0)
 ;
"RTN","ZISFM",93,0)
 ;
"RTN","ZISFM",94,0)
 ;
"RTN","ZISFM",95,0)
 ;
"RTN","ZISFM",96,0)
 ;
"RTN","ZISFM",97,0)
 ;
"RTN","ZISFM",98,0)
 ;
"RTN","ZISFM",99,0)
 ;
"RTN","ZISFM",100,0)
 ;
"RTN","ZISPQ")
0^2^B101069140^n/a
"RTN","ZISPQ",1,0)
ZISPQ ;IRMFO-ALB/CJM - DEVICE HANDLER PRINT QUEUES;10/05/2011 ;08/01/2012
"RTN","ZISPQ",2,0)
 ;;8.0;KERNEL;**585**;JUL 10, 9;Build 22
"RTN","ZISPQ",3,0)
 ;Per VHA Directive 10-93-142, this routine should not be modified.
"RTN","ZISPQ",4,0)
 ;
"RTN","ZISPQ",5,0)
QEXIST(DEVICE) ;
"RTN","ZISPQ",6,0)
 ;Check if print queue exists for this device on this system
"RTN","ZISPQ",7,0)
 ;
"RTN","ZISPQ",8,0)
 ;Input:
"RTN","ZISPQ",9,0)
 ;  DEVICE = ien of device
"RTN","ZISPQ",10,0)
 ;Output:
"RTN","ZISPQ",11,0)
 ;  Function returns 1 if queue associated with DEVICE exists, 0 otherwise
"RTN","ZISPQ",12,0)
 ;
"RTN","ZISPQ",13,0)
 N OS,PQ
"RTN","ZISPQ",14,0)
 S PQ=$$GETPQ(DEVICE)
"RTN","ZISPQ",15,0)
 Q:PQ="" 0
"RTN","ZISPQ",16,0)
 S OS=$$OS^%ZOSV()
"RTN","ZISPQ",17,0)
 I OS["UNIX" Q $$LQEXIST(PQ)
"RTN","ZISPQ",18,0)
 E  I OS["VMS" Q $$VQEXIST(PQ)
"RTN","ZISPQ",19,0)
 Q 0
"RTN","ZISPQ",20,0)
 ;
"RTN","ZISPQ",21,0)
OPEN ;called from PQ^%ZIS6
"RTN","ZISPQ",22,0)
 ;
"RTN","ZISPQ",23,0)
 ;override %ZIS input parameters and device file parameters for printer queues
"RTN","ZISPQ",24,0)
 ;
"RTN","ZISPQ",25,0)
 W:'$D(IOP) !
"RTN","ZISPQ",26,0)
 D:'POP&(%ZISB&(%ZIS'["T"))
"RTN","ZISPQ",27,0)
 .K %ZIS("IOPAR"),%ZIS("IOUPAR")
"RTN","ZISPQ",28,0)
 .S %ZISTO=2
"RTN","ZISPQ",29,0)
 .S $P(%ZTIME,"^",3)="n"
"RTN","ZISPQ",30,0)
 .I $$OS^%ZOSV()["UNIX" D
"RTN","ZISPQ",31,0)
 ..S %ZISOPAR="(""NWU"":/TER=$CHAR(13))"
"RTN","ZISPQ",32,0)
 .E  D
"RTN","ZISPQ",33,0)
 ..S %ZISOPAR="(""NWS"")"
"RTN","ZISPQ",34,0)
 .S %ZISUPAR=""
"RTN","ZISPQ",35,0)
 .S IO=$$NEWJOB(%E,+$G(DUZ)) ;get a unique name for host file
"RTN","ZISPQ",36,0)
 .Q:IO=""
"RTN","ZISPQ",37,0)
 .I $$FEXIST(IO) D FDELETE(IO) ;make sure the file does not exist - it should not!
"RTN","ZISPQ",38,0)
 .S %ZISLOCK=$NA(^%ZIS("lock",IO))
"RTN","ZISPQ",39,0)
 .D O^%ZIS4
"RTN","ZISPQ",40,0)
 .I POP D STATUS(IO,"QE")
"RTN","ZISPQ",41,0)
 ;
"RTN","ZISPQ",42,0)
 Q
"RTN","ZISPQ",43,0)
 ;
"RTN","ZISPQ",44,0)
DIR(CODE) ;get directory for printer queues, a subdirectory of host file directory
"RTN","ZISPQ",45,0)
 ;Input - CODE (optional) 1 for primary, 2 for secondary.  If not passed, the directory of the current process is assumed
"RTN","ZISPQ",46,0)
 N DIR
"RTN","ZISPQ",47,0)
 I '$G(CODE) S CODE=$$PRI^%ZOSV
"RTN","ZISPQ",48,0)
 S DIR=$$CHKNM^%ZISF($P($G(^XTV(8989.3,1,"DEV")),"^",CODE))
"RTN","ZISPQ",49,0)
 I $$OS^%ZOSV()["VMS" D
"RTN","ZISPQ",50,0)
 .S DIR=$P(DIR,"]")_".print_queues]"
"RTN","ZISPQ",51,0)
 E  D
"RTN","ZISPQ",52,0)
 .I $E(DIR,$L(DIR))'="/" S DIR=DIR_"/"
"RTN","ZISPQ",53,0)
 .S DIR=DIR_"print_queues/"
"RTN","ZISPQ",54,0)
 Q DIR
"RTN","ZISPQ",55,0)
 ;
"RTN","ZISPQ",56,0)
NEWJOB(DEVICE,DUZ) ;
"RTN","ZISPQ",57,0)
 ;Creates a new entry in the PRINT QUEUE JOB file and creates a unique
"RTN","ZISPQ",58,0)
 ;name for the print file.
"RTN","ZISPQ",59,0)
 ;
"RTN","ZISPQ",60,0)
 ;Input:
"RTN","ZISPQ",61,0)
 ;  DEVICE - ien of the device
"RTN","ZISPQ",62,0)
 ;  DUZ
"RTN","ZISPQ",63,0)
 ;Output:
"RTN","ZISPQ",64,0)
 ;  Function value - returns the full path name of the host file for the print queue.
"RTN","ZISPQ",65,0)
 ;
"RTN","ZISPQ",66,0)
 N I,DATA,DIR,PQ,JOB
"RTN","ZISPQ",67,0)
 I '$G(DEVICE) S POP=1 Q ""
"RTN","ZISPQ",68,0)
 ;
"RTN","ZISPQ",69,0)
 ;Get the name of the print queue
"RTN","ZISPQ",70,0)
 S PQ=$$GETPQ(DEVICE)
"RTN","ZISPQ",71,0)
 I PQ="" S POP=1 Q ""
"RTN","ZISPQ",72,0)
 ;
"RTN","ZISPQ",73,0)
 S DATA(.01)=DEVICE,DATA(.02)=$$NOW^XLFDT,DATA(.04)=DUZ,DATA(.05)=PQ,DATA(.09)=$$PRI^%ZOSV
"RTN","ZISPQ",74,0)
 S JOB=$$ADD^ZISFM(3.52,,.DATA,.ERROR)
"RTN","ZISPQ",75,0)
 Q:'JOB ""
"RTN","ZISPQ",76,0)
 ;
"RTN","ZISPQ",77,0)
 ;add the status
"RTN","ZISPQ",78,0)
 S DATA(.07)="O"
"RTN","ZISPQ",79,0)
 ;add the filename -including the UCI and ien guarantees it to be unique
"RTN","ZISPQ",80,0)
 S DATA(.06)="PQ$"_$$UCI_"_"_JOB_".TXT"
"RTN","ZISPQ",81,0)
 D UPD^ZISFM(3.52,JOB,.DATA,.ERROR)
"RTN","ZISPQ",82,0)
 Q $$DIR_DATA(.06)
"RTN","ZISPQ",83,0)
 ;
"RTN","ZISPQ",84,0)
STATUS(IO,STATUS,JOBID) ;Set the status of the PRINT QUEUE JOB
"RTN","ZISPQ",85,0)
 ;Input:
"RTN","ZISPQ",86,0)
 ;  IO - file name, may include or not include the path, the ien is parsed out.
"RTN","ZISPQ",87,0)
 ;  STATUS (optional) status code. If ="" returns the current status.
"RTN","ZISPQ",88,0)
 ;  JOBID (optional) The job id.  Should be passed in if the status is 'Q'ueued
"RTN","ZISPQ",89,0)
 ;Output:
"RTN","ZISPQ",90,0)
 ;  function returns the current status
"RTN","ZISPQ",91,0)
 ;
"RTN","ZISPQ",92,0)
 N IEN,DATA,ERROR
"RTN","ZISPQ",93,0)
 Q:'$L($G(IO)) ""
"RTN","ZISPQ",94,0)
 S IEN=$$GETIEN(IO)
"RTN","ZISPQ",95,0)
 Q:IEN="" ""
"RTN","ZISPQ",96,0)
 I $G(STATUS)="" Q $P($G(^%ZIS(3.52,IEN,0)),"^",7)
"RTN","ZISPQ",97,0)
 I $L($G(JOBID)) S DATA(.08)=JOBID
"RTN","ZISPQ",98,0)
 S DATA(.07)=STATUS
"RTN","ZISPQ",99,0)
 I $E(STATUS,1)="Q" S DATA(.03)=$$NOW^XLFDT
"RTN","ZISPQ",100,0)
 I STATUS="C",$P($G(^%ZIS(3.52,IEN,0)),"^",7)="C" S DATA(.03)=$$NOW^XLFDT
"RTN","ZISPQ",101,0)
 D UPD^ZISFM(3.52,IEN,.DATA,.ERROR)
"RTN","ZISPQ",102,0)
 Q STATUS
"RTN","ZISPQ",103,0)
 ;
"RTN","ZISPQ",104,0)
CLOSE(IO) ;Called from ^%ZISC. Closes the host file and passes it to the print queue
"RTN","ZISPQ",105,0)
 ;
"RTN","ZISPQ",106,0)
 N JOBID,STATUS
"RTN","ZISPQ",107,0)
 ;
"RTN","ZISPQ",108,0)
 S STATUS=$$STATUS(IO)
"RTN","ZISPQ",109,0)
 ;
"RTN","ZISPQ",110,0)
 ;queued tasks are calling CLOSE logic twice, check for that
"RTN","ZISPQ",111,0)
 I (STATUS="Q")!(STATUS="P")!(STATUS="D") Q
"RTN","ZISPQ",112,0)
 ;
"RTN","ZISPQ",113,0)
 I '$$PRINT(IO,.JOBID) S STATUS="QE"
"RTN","ZISPQ",114,0)
 E  S STATUS="Q"
"RTN","ZISPQ",115,0)
 D STATUS(IO,STATUS,$G(JOBID))
"RTN","ZISPQ",116,0)
 Q
"RTN","ZISPQ",117,0)
 ;
"RTN","ZISPQ",118,0)
VQEXIST(Q) ; Tests if queue exists on this node - VMS
"RTN","ZISPQ",119,0)
 ;Function returns 1 if the queue exists, 0 if it doesn't
"RTN","ZISPQ",120,0)
 ;
"RTN","ZISPQ",121,0)
 N CMD,RET
"RTN","ZISPQ",122,0)
 S CMD="PIPE Q = F$GETQUI(""DISPLAY_QUEUE"",""QUEUE_NAME"","""_Q_""")"
"RTN","ZISPQ",123,0)
 S CMD=CMD_" ; IF F$LENGTH(Q) .EQ. 0 THEN DEFINE/JOB ZIS$VAL 0 ; IF F$LENGTH(Q) .GT. 0 THEN DEFINE/JOB ZIS$VAL 1 "
"RTN","ZISPQ",124,0)
 I $ZF(-1,CMD)
"RTN","ZISPQ",125,0)
 S RET=$ZF("TRNLNM","ZIS$VAL","LNM$JOB")
"RTN","ZISPQ",126,0)
 I $ZF(-1,"DEASSIGN/JOB ZIS$VAL")
"RTN","ZISPQ",127,0)
 Q +$G(RET)
"RTN","ZISPQ",128,0)
 ;
"RTN","ZISPQ",129,0)
LQEXIST(Q) ; Tests if queue exists - LINUX
"RTN","ZISPQ",130,0)
 N EOF,CMD,RESULTS,RET
"RTN","ZISPQ",131,0)
 S EOF=$ZU(68,40,1)
"RTN","ZISPQ",132,0)
 S CMD="lpstat -p "_$$REPLACE(Q,"$","'$'")_" 2> /dev/null"
"RTN","ZISPQ",133,0)
 O CMD:"qr" U CMD R RESULTS:2 C CMD
"RTN","ZISPQ",134,0)
 I RESULTS]"" S RET=1
"RTN","ZISPQ",135,0)
 S EOF=$ZU(68,40,EOF)
"RTN","ZISPQ",136,0)
 Q +$G(RET)
"RTN","ZISPQ",137,0)
 ;
"RTN","ZISPQ",138,0)
PRINT(FILE,JOBID) ;Submits the file to be printed.
"RTN","ZISPQ",139,0)
 ;Input:
"RTN","ZISPQ",140,0)
 ;   FILE - full file name, including path
"RTN","ZISPQ",141,0)
 ;Output:
"RTN","ZISPQ",142,0)
 ;   function value - returns 1 on success, 0 on failure
"RTN","ZISPQ",143,0)
 ;   JOBID (pass by reference) on sucess may return the job id for the print job (not guaranteed)
"RTN","ZISPQ",144,0)
 N OS,JOB
"RTN","ZISPQ",145,0)
 S JOB=FILE
"RTN","ZISPQ",146,0)
 Q:'$$GETJOB(.JOB) 0
"RTN","ZISPQ",147,0)
 S OS=$$OS^%ZOSV()
"RTN","ZISPQ",148,0)
 I OS["UNIX" Q $$LPRINT(FILE,JOB("QUEUE"),.JOBID)
"RTN","ZISPQ",149,0)
 I OS["VMS" Q $$VPRINT(FILE,JOB("QUEUE"),.JOBID)
"RTN","ZISPQ",150,0)
 Q 0
"RTN","ZISPQ",151,0)
 ;
"RTN","ZISPQ",152,0)
LPRINT(FILE,Q,JOBID) ;
"RTN","ZISPQ",153,0)
 N CMD,RESULT,EOF,RET
"RTN","ZISPQ",154,0)
 S RET=0,JOBID=""
"RTN","ZISPQ",155,0)
 S CMD="lpr -r -P"_Q_" "_FILE_" && echo success && lpq -P "_Q
"RTN","ZISPQ",156,0)
 S CMD=$$REPLACE(CMD,"$","'$'")
"RTN","ZISPQ",157,0)
 S EOF=$ZU(68,40,1)
"RTN","ZISPQ",158,0)
 O CMD:"QR":5 Q:'$T  U CMD D  C CMD
"RTN","ZISPQ",159,0)
 .R RESULT:5 Q:'$T  Q:RESULT=""
"RTN","ZISPQ",160,0)
 .I RESULT["success" D
"RTN","ZISPQ",161,0)
 ..N NAME
"RTN","ZISPQ",162,0)
 ..S NAME="PQ$JOB_"_$P(FILE,"PQ$JOB_",2)
"RTN","ZISPQ",163,0)
 ..S RET=1
"RTN","ZISPQ",164,0)
 ..F  R RESULT:5 Q:'$T  Q:RESULT=""  I RESULT[NAME S JOBID=$$INVERT^XLFSTR($P($$INVERT^XLFSTR($$TRIM^XLFSTR($P(RESULT,NAME),"R"))," ")) Q
"RTN","ZISPQ",165,0)
 S EOF=$ZU(68,40,EOF)
"RTN","ZISPQ",166,0)
 Q RET
"RTN","ZISPQ",167,0)
 ;
"RTN","ZISPQ",168,0)
VPRINT(FILE,Q,JOBID) ; VMS Print
"RTN","ZISPQ",169,0)
 ;First determine the /PASS or /NOPASS parameter
"RTN","ZISPQ",170,0)
 N CMD,PASS,NOPASS,RET
"RTN","ZISPQ",171,0)
 S RET=0,JOBID=""
"RTN","ZISPQ",172,0)
 S CMD="PIPE DESCR = F$GETQUI(""DISPLAY_QUEUE"",""QUEUE_DESCRIPTION"","""_Q_""")"
"RTN","ZISPQ",173,0)
 S CMD=CMD_" ; IF F$LOCATE( ""/NOPASS"",DESCR) .LT. F$LENGTH(DESCR) THEN DEFINE/JOB ZIS$VAL 1 "
"RTN","ZISPQ",174,0)
 I $ZF(-1,CMD)
"RTN","ZISPQ",175,0)
 ;
"RTN","ZISPQ",176,0)
 S NOPASS=+$ZF("TRNLNM","ZIS$VAL","LNM$JOB")
"RTN","ZISPQ",177,0)
 I $ZF(-1,"DEASSIGN/JOB/NOLOG ZIS$VAL")
"RTN","ZISPQ",178,0)
 S PASS=$S(NOPASS:"/NOPASS",1:"/PASS")
"RTN","ZISPQ",179,0)
 ;
"RTN","ZISPQ",180,0)
 ;Build the complete VMS PRINT command
"RTN","ZISPQ",181,0)
 S CMD="PIPE PRINT/DELETE"_PASS_"/NOIDENTITY/QUEUE="""_Q_""" "_FILE_" /PARAM=NOFLAG ; IF $STATUS THEN DEFINE/JOB ZIS$VAL &$ENTRY "
"RTN","ZISPQ",182,0)
 ;
"RTN","ZISPQ",183,0)
 I $ZF(-1,CMD)=1 D
"RTN","ZISPQ",184,0)
 .S JOBID=$ZF("TRNLNM","ZIS$VAL","LNM$JOB")
"RTN","ZISPQ",185,0)
 I JOBID'="",$ZF(-1,"DEASSIGN/JOB/NOLOG ZIS$VAL")
"RTN","ZISPQ",186,0)
 Q JOBID'=""
"RTN","ZISPQ",187,0)
 ;
"RTN","ZISPQ",188,0)
GETPQ(DEVICE) ;
"RTN","ZISPQ",189,0)
 ;Given the ien of the DEVICE, it returns the name of the print queue,
"RTN","ZISPQ",190,0)
 ;parsed from the $I or SECONDARY $I field of the DEVICE
"RTN","ZISPQ",191,0)
 ;
"RTN","ZISPQ",192,0)
 ;Returns "" on failure
"RTN","ZISPQ",193,0)
 ;
"RTN","ZISPQ",194,0)
 Q:'$G(DEVICE) ""
"RTN","ZISPQ",195,0)
 N PQ
"RTN","ZISPQ",196,0)
 ;
"RTN","ZISPQ",197,0)
 ;get $I and parse out the name of the print queue
"RTN","ZISPQ",198,0)
 S:$$PRI^%ZOSV=2 PQ=$P($G(^%ZIS(1,DEVICE,2)),"^")
"RTN","ZISPQ",199,0)
 S:$G(PQ)="" PQ=$P($G(^%ZIS(1,DEVICE,0)),"^",2)
"RTN","ZISPQ",200,0)
 ;
"RTN","ZISPQ",201,0)
 ;$I field might look like this:  DEV:[TEMP]HF_QUEUE.TXT -  parse out thequeue name
"RTN","ZISPQ",202,0)
 I PQ[":" S PQ=$P(PQ,":",2)
"RTN","ZISPQ",203,0)
 S PQ=$P(PQ,".",1)
"RTN","ZISPQ",204,0)
 I PQ["]" S PQ=$P(PQ,"]",2)
"RTN","ZISPQ",205,0)
 ;
"RTN","ZISPQ",206,0)
 Q PQ
"RTN","ZISPQ",207,0)
 ;
"RTN","ZISPQ",208,0)
REPLACE(STRING,SUB1,SUB2) ;
"RTN","ZISPQ",209,0)
 N REPLACE
"RTN","ZISPQ",210,0)
 S REPLACE(SUB1)=SUB2
"RTN","ZISPQ",211,0)
 Q $$REPLACE^XLFSTR(STRING,.REPLACE)
"RTN","ZISPQ",212,0)
 ;
"RTN","ZISPQ",213,0)
ID ;identifier logic on the PRINT QUEUES JOB file
"RTN","ZISPQ",214,0)
 N ID,NAME,DATE
"RTN","ZISPQ",215,0)
 S NAME=$P(^(0),"^",4)
"RTN","ZISPQ",216,0)
 S DATE=$P(^(0),"^",2)
"RTN","ZISPQ",217,0)
 I NAME S NAME=$$LJ^XLFSTR($P($G(^VA(200,NAME,0)),"^"),18)_" "
"RTN","ZISPQ",218,0)
 I DATE S DATE=$$FMTE^XLFDT(DATE)
"RTN","ZISPQ",219,0)
 S ID=$E(NAME,1,20)_" "_DATE
"RTN","ZISPQ",220,0)
 D EN^DDIOL(ID,"")
"RTN","ZISPQ",221,0)
 Q
"RTN","ZISPQ",222,0)
 ;
"RTN","ZISPQ",223,0)
PURGE ;Purge of PRINT JOB QUEUES (file #3.52) and old host files that were queued.  Also updates status on a regular basis.
"RTN","ZISPQ",224,0)
 ;
"RTN","ZISPQ",225,0)
 N DEVICE,STATUS,TIME,IEN,DIR,T1,T2,T3,NOW
"RTN","ZISPQ",226,0)
 S NOW=$$NOW^XLFDT
"RTN","ZISPQ",227,0)
 S ZTREQ=""
"RTN","ZISPQ",228,0)
 ;
"RTN","ZISPQ",229,0)
 ;set time parameters for this purge
"RTN","ZISPQ",230,0)
 S T1=$$FMADD^XLFDT(NOW,,-1) ;10 minutes ago
"RTN","ZISPQ",231,0)
 S T2=$$FMADD^XLFDT(NOW,-1) ;24 hours ago
"RTN","ZISPQ",232,0)
 S T3=$$FMADD^XLFDT(NOW,-2) ;48 hours ago
"RTN","ZISPQ",233,0)
 ;
"RTN","ZISPQ",234,0)
 S DIR=$$PRI^%ZOSV
"RTN","ZISPQ",235,0)
 ;
"RTN","ZISPQ",236,0)
 L +%ZIS(3.52,"PURGE JOB"_DIR):0 Q:'$T  ;allow only one purge at a time on each system (primary, secondary)
"RTN","ZISPQ",237,0)
 ;
"RTN","ZISPQ",238,0)
 ;look for queued jobs older than 10 minutes whose status can be changed to 'PRINTED & DELETED'
"RTN","ZISPQ",239,0)
 S STATUS="Q"
"RTN","ZISPQ",240,0)
 S DEVICE=0
"RTN","ZISPQ",241,0)
 F  S DEVICE=$O(^%ZIS(3.52,"E",DIR,DEVICE)) Q:'DEVICE  D
"RTN","ZISPQ",242,0)
 .S TIME=T2 F  S TIME=$O(^%ZIS(3.52,"E",DIR,DEVICE,STATUS,TIME)) Q:'TIME  Q:TIME>T1  D
"RTN","ZISPQ",243,0)
 ..S IEN=0 F  S IEN=$O(^%ZIS(3.52,"E",DIR,DEVICE,STATUS,TIME,IEN)) Q:'IEN  D
"RTN","ZISPQ",244,0)
 ...N JOB S JOB=IEN
"RTN","ZISPQ",245,0)
 ...I '$$GETJOB(.JOB) Q
"RTN","ZISPQ",246,0)
 ...;if the host file is gone, it has been printed
"RTN","ZISPQ",247,0)
 ...I $$FEXIST(JOB("FILE")) D STATUS(JOB("FILE"),"D")
"RTN","ZISPQ",248,0)
 ;
"RTN","ZISPQ",249,0)
 ;delete host files older than 24 hours
"RTN","ZISPQ",250,0)
 S DEVICE=0
"RTN","ZISPQ",251,0)
 F  S DEVICE=$O(^%ZIS(3.52,"E",DIR,DEVICE)) Q:'DEVICE  D
"RTN","ZISPQ",252,0)
 .Q:$$STOPPED(DEVICE)
"RTN","ZISPQ",253,0)
 .S STATUS=""
"RTN","ZISPQ",254,0)
 .F  S STATUS=$O(^%ZIS(3.52,"E",DIR,DEVICE,STATUS)) Q:STATUS=""  I STATUS'="P",STATUS'="D"  D
"RTN","ZISPQ",255,0)
 ..S TIME=0
"RTN","ZISPQ",256,0)
 ..F  S TIME=$O(^%ZIS(3.52,"E",DIR,DEVICE,STATUS,TIME)) Q:'TIME  Q:TIME>T2  D
"RTN","ZISPQ",257,0)
 ...S IEN=0 F  S IEN=$O(^%ZIS(3.52,"E",DIR,DEVICE,STATUS,TIME,IEN)) Q:'IEN  D
"RTN","ZISPQ",258,0)
 ....N JOB S JOB=IEN
"RTN","ZISPQ",259,0)
 ....I '$$GETJOB(.JOB) K ^%ZIS(3.52,"E",DIR,DEVICE,STATUS,TIME,IEN) Q
"RTN","ZISPQ",260,0)
 ....;delete the host file if it exists and change the status
"RTN","ZISPQ",261,0)
 ....I $$FEXIST(JOB("FILE")) D FDELETE(JOB("FILE")),STATUS(JOB("FILE"),"D")
"RTN","ZISPQ",262,0)
 ;
"RTN","ZISPQ",263,0)
 ;delete jobs (file #3.52) older than 48 hours
"RTN","ZISPQ",264,0)
 S DEVICE=0
"RTN","ZISPQ",265,0)
 F  S DEVICE=$O(^%ZIS(3.52,"E",DIR,DEVICE)) Q:'DEVICE  D
"RTN","ZISPQ",266,0)
 .Q:$$STOPPED(DEVICE)
"RTN","ZISPQ",267,0)
 .S STATUS="" F  S STATUS=$O(^%ZIS(3.52,"E",DIR,DEVICE,STATUS)) Q:STATUS=""  D
"RTN","ZISPQ",268,0)
 ..S TIME=0 F  S TIME=$O(^%ZIS(3.52,"E",DIR,DEVICE,STATUS,TIME)) Q:'TIME  Q:TIME>T3  D
"RTN","ZISPQ",269,0)
 ...S IEN=0 F  S IEN=$O(^%ZIS(3.52,"E",DIR,DEVICE,STATUS,TIME,IEN)) Q:'IEN  D
"RTN","ZISPQ",270,0)
 ....N JOB S JOB=IEN
"RTN","ZISPQ",271,0)
 ....I '$$GETJOB(.JOB) K ^%ZIS(3.52,"E",DIR,DEVICE,STATUS,TIME,IEN) Q
"RTN","ZISPQ",272,0)
 ....;delete the job entry (file #3.52)
"RTN","ZISPQ",273,0)
 ....D JDELETE(IEN)
"RTN","ZISPQ",274,0)
 ;
"RTN","ZISPQ",275,0)
 L -%ZIS(3.52,"PURGE JOB"_DIR)
"RTN","ZISPQ",276,0)
 Q
"RTN","ZISPQ",277,0)
 ;
"RTN","ZISPQ",278,0)
GETJOB(JOB) ;returns job info (file 3.52).  Input JOB=ien OR the name of the host file, returns .JOB array with job's fields
"RTN","ZISPQ",279,0)
 N NODE,FILE,DIR,IEN
"RTN","ZISPQ",280,0)
 S IEN=$G(JOB)
"RTN","ZISPQ",281,0)
 I 'IEN,$L(IEN) S IEN=$$GETIEN(IEN)
"RTN","ZISPQ",282,0)
 Q:'IEN ""
"RTN","ZISPQ",283,0)
 S JOB("IEN")=IEN
"RTN","ZISPQ",284,0)
 S NODE=$G(^%ZIS(3.52,IEN,0))
"RTN","ZISPQ",285,0)
 Q:NODE="" 0
"RTN","ZISPQ",286,0)
 S JOB("QUEUE")=$P(NODE,"^",5)
"RTN","ZISPQ",287,0)
 S JOB("ID")=$P(NODE,"^",8)
"RTN","ZISPQ",288,0)
 S FILE=$P(NODE,"^",6)
"RTN","ZISPQ",289,0)
 S DIR=$P(NODE,"^",9)
"RTN","ZISPQ",290,0)
 S DIR=$$DIR(DIR)
"RTN","ZISPQ",291,0)
 S FILE=DIR_FILE
"RTN","ZISPQ",292,0)
 S JOB("FILE")=FILE
"RTN","ZISPQ",293,0)
 Q 1
"RTN","ZISPQ",294,0)
 ;
"RTN","ZISPQ",295,0)
STOPPED(DEVICE) ;was purging suspended for this device?
"RTN","ZISPQ",296,0)
 N RET
"RTN","ZISPQ",297,0)
 S RET=$P($G(^%ZIS(1,+DEVICE,0)),"^",13)
"RTN","ZISPQ",298,0)
 I RET="N" Q 1
"RTN","ZISPQ",299,0)
 Q 0
"RTN","ZISPQ",300,0)
 ;
"RTN","ZISPQ",301,0)
FEXIST(FILE) ;returns 1 if the file exists, 0 otherwise
"RTN","ZISPQ",302,0)
 ;
"RTN","ZISPQ",303,0)
 N OS S OS=$$OS^%ZOSV()
"RTN","ZISPQ",304,0)
 I OS["UNIX" Q $$LFEXIST(FILE)
"RTN","ZISPQ",305,0)
 E  I OS["VMS" Q $$VFEXIST(FILE)
"RTN","ZISPQ",306,0)
 Q 0
"RTN","ZISPQ",307,0)
 ;
"RTN","ZISPQ",308,0)
VFEXIST(FILE) ;checks file's existance - VMS
"RTN","ZISPQ",309,0)
 N CMD,RET
"RTN","ZISPQ",310,0)
 S CMD="PIPE F = F$SEARCH("""_FILE_""")"
"RTN","ZISPQ",311,0)
 S CMD=CMD_" ; IF F$LENGTH(F) .EQ. 0 THEN DEFINE/JOB ZIS$VAL 0 ; IF F$LENGTH(F) .GT. 0 THEN DEFINE/JOB ZIS$VAL 1 "
"RTN","ZISPQ",312,0)
 I $ZF(-1,CMD)
"RTN","ZISPQ",313,0)
 S RET=$ZF("TRNLNM","ZIS$VAL","LNM$JOB")
"RTN","ZISPQ",314,0)
 I $ZF(-1,"DEASSIGN/JOB ZIS$VAL")
"RTN","ZISPQ",315,0)
 Q +$G(RET)
"RTN","ZISPQ",316,0)
 ;
"RTN","ZISPQ",317,0)
LFEXIST(FILE) ;checks file's existance - Linux,Unix
"RTN","ZISPQ",318,0)
 N CMD
"RTN","ZISPQ",319,0)
 S CMD="[ -f "_$$REPLACE(FILE,"$","'$'")_" ]"
"RTN","ZISPQ",320,0)
 Q '$ZF(-1,CMD)
"RTN","ZISPQ",321,0)
 ;
"RTN","ZISPQ",322,0)
FDELETE(FILE) ;delete file
"RTN","ZISPQ",323,0)
 N OS S OS=$$OS^%ZOSV()
"RTN","ZISPQ",324,0)
 I OS["UNIX" D LFDELETE(FILE)
"RTN","ZISPQ",325,0)
 E  I OS["VMS" D VFDELETE(FILE)
"RTN","ZISPQ",326,0)
 Q
"RTN","ZISPQ",327,0)
 ;
"RTN","ZISPQ",328,0)
VFDELETE(FILE) ;delete file - VMS
"RTN","ZISPQ",329,0)
 N CMD
"RTN","ZISPQ",330,0)
 I FILE'[";" S FILE=FILE_";*"
"RTN","ZISPQ",331,0)
 S CMD="DELETE "_FILE
"RTN","ZISPQ",332,0)
 I $ZF(-1,CMD)
"RTN","ZISPQ",333,0)
 Q
"RTN","ZISPQ",334,0)
 ;
"RTN","ZISPQ",335,0)
LFDELETE(FILE) ;delete file - Linux,Unix
"RTN","ZISPQ",336,0)
 N CMD
"RTN","ZISPQ",337,0)
 S CMD="rm -f "_$$REPLACE(FILE,"$","'$'")
"RTN","ZISPQ",338,0)
 I $ZF(-1,CMD)
"RTN","ZISPQ",339,0)
 Q
"RTN","ZISPQ",340,0)
 ;
"RTN","ZISPQ",341,0)
JDELETE(IEN) ;delete the job, file #3.52
"RTN","ZISPQ",342,0)
 D DELETE^ZISFM(3.52,IEN)
"RTN","ZISPQ",343,0)
 Q
"RTN","ZISPQ",344,0)
 ;
"RTN","ZISPQ",345,0)
DEQUEUE(JOBID,QUEUE) ;Remove a job from a queue
"RTN","ZISPQ",346,0)
 N OS S OS=$$OS^%ZOSV()
"RTN","ZISPQ",347,0)
 I OS["UNIX" Q $$LDEQUEUE(JOBID,QUEUE)
"RTN","ZISPQ",348,0)
 E  I OS["VMS" Q $$VDEQUEUE(JOBID,QUEUE)
"RTN","ZISPQ",349,0)
 Q
"RTN","ZISPQ",350,0)
 ;
"RTN","ZISPQ",351,0)
VDEQUEUE(JOBID,QUEUE) ;Remove a job from a queue - VMS
"RTN","ZISPQ",352,0)
 I $ZF(-1,"DELETE /ENTRY="_JOBID_" "_QUEUE)
"RTN","ZISPQ",353,0)
 Q
"RTN","ZISPQ",354,0)
 ;
"RTN","ZISPQ",355,0)
LDEQUEUE(JOBID,QUEUE) ;Remove a job from a queue - Linux, Unix
"RTN","ZISPQ",356,0)
 N CMD
"RTN","ZISPQ",357,0)
 S CMD="lprm -P "_$$REPLACE(QUEUE,"$","'$'")_" "_JOBID
"RTN","ZISPQ",358,0)
 I $ZF(-1,CMD)
"RTN","ZISPQ",359,0)
 Q
"RTN","ZISPQ",360,0)
UCI() ;return the UCI
"RTN","ZISPQ",361,0)
 N Y
"RTN","ZISPQ",362,0)
 X ^%ZOSF("UCI")
"RTN","ZISPQ",363,0)
 Q $P(Y,",")
"RTN","ZISPQ",364,0)
 ;
"RTN","ZISPQ",365,0)
GETIEN(FILE) ;given the file name, parses out the ien and returns it
"RTN","ZISPQ",366,0)
 Q $P($P(FILE,"PQ$"_$$UCI_"_",2),".TXT")
"RTN","ZISPQ",367,0)
 ;
"RTN","ZISPQ",368,0)
 ;
"RTN","ZISPQ",369,0)
 ;
"RTN","ZISPQ",370,0)
 ;
"RTN","ZISX")
0^1^B1066676^B220757
"RTN","ZISX",1,0)
ZISX ;SF/GFT,AC - PROGRAM THAT XECUTES NODES IN ^%ZIS GLOBAL. ;10/26/2011
"RTN","ZISX",2,0)
 ;;8.0;KERNEL;**585**;Jul 10, 1995;Build 22
"RTN","ZISX",3,0)
 ;Close execute
"RTN","ZISX",4,0)
X3 D XECUTE($G(^%ZIS(2,+IOST(0),3))) Q
"RTN","ZISX",5,0)
X31 ;X ^%ZIS(2,+IOST(0),3.1) Q  ;Old code
"RTN","ZISX",6,0)
 ;Open printer port
"RTN","ZISX",7,0)
X10 D XECUTE($G(^%ZIS(2,IO("S"),10))) Q
"RTN","ZISX",8,0)
 ;Close printer port
"RTN","ZISX",9,0)
X11 D XECUTE($G(^%ZIS(2,+IO("S"),11))) K IO("S") Q
"RTN","ZISX",10,0)
 ;Pre-Close
"RTN","ZISX",11,0)
XPCX D XECUTE($G(^%ZIS(1,+IOS,"PCX"))) Q
"RTN","ZISX",12,0)
XPOX(X) ;Execute pre-open execute code.
"RTN","ZISX",13,0)
 D XECUTE($G(^%ZIS(1,+X,"POX"))) Q
"RTN","ZISX",14,0)
 ;General
"RTN","ZISX",15,0)
%Y D XECUTE($G(%Y)) Q
"RTN","ZISX",16,0)
XS X %ZIS("S") Q
"RTN","ZISX",17,0)
XW X %ZIS("W") Q
"RTN","ZISX",18,0)
 ;
"RTN","ZISX",19,0)
 ;**P585 START CJM
"RTN","ZISX",20,0)
 ;ignore calls to CLOSE^NVSPRTU and PREOPEN^NVSPRTU if the device type is "PQ"=Print Queue
"RTN","ZISX",21,0)
XECUTE(NODE) ;
"RTN","ZISX",22,0)
 I ($G(%ZTYPE)="PQ")!($G(IOT)="PQ") D
"RTN","ZISX",23,0)
 .N REPLACE
"RTN","ZISX",24,0)
 .S REPLACE("PREOPEN^NVSPRTU")="PREOPEN^ZISX"
"RTN","ZISX",25,0)
 .S REPLACE("CLOSE^NVSPRTU")="CLOSE^ZISX"
"RTN","ZISX",26,0)
 .S NODE=$$REPLACE^XLFSTR(NODE,.REPLACE)
"RTN","ZISX",27,0)
 .X NODE
"RTN","ZISX",28,0)
 E  D
"RTN","ZISX",29,0)
 .X NODE
"RTN","ZISX",30,0)
 Q
"RTN","ZISX",31,0)
CLOSE ;
"RTN","ZISX",32,0)
 Q
"RTN","ZISX",33,0)
PREOPEN(X) ;
"RTN","ZISX",34,0)
 Q $G(X)
"RTN","ZISX",35,0)
 ;**P585 END
"VER")
8.0^22.0
"^DD",3.5,3.5,.13,0)
PURGE OLD PRINT QUEUE FILES^S^Y:YES;N:NO;^0;13^Q
"^DD",3.5,3.5,.13,3)
Should old files in the Print Queue Directory be deleted?
"^DD",3.5,3.5,.13,21,0)
^^18^18^3111107^^^
"^DD",3.5,3.5,.13,21,1,0)
This field determines whether old HFS files associated with entries in the
"^DD",3.5,3.5,.13,21,2,0)
PRINT QUEUE JOB (#3.52) file should be deleted. It only applies to devices
"^DD",3.5,3.5,.13,21,3,0)
of the PRINT QUEUE type. For print queues, an intermediate host file is
"^DD",3.5,3.5,.13,21,4,0)
created in the PRINT_QUEUES subdirectory. 
"^DD",3.5,3.5,.13,21,5,0)

"^DD",3.5,3.5,.13,21,6,0)
Normally, these files are automatically deleted once they have been submitted
"^DD",3.5,3.5,.13,21,7,0)
to the print queue.  For those files that are not automatically deleted,
"^DD",3.5,3.5,.13,21,8,0)
there is a scheduled option that will periodically delete host files that
"^DD",3.5,3.5,.13,21,9,0)
have been somehow left in existence past their usefulness.
"^DD",3.5,3.5,.13,21,10,0)

"^DD",3.5,3.5,.13,21,11,0)
Setting this field to NO will prevent the purge option from deleting HFS files
"^DD",3.5,3.5,.13,21,12,0)
created via this device.  Setting this field to NO should only be done on
"^DD",3.5,3.5,.13,21,13,0)
a temporary basis while troubleshooting a problem involving a print queue. 
"^DD",3.5,3.5,.13,21,14,0)

"^DD",3.5,3.5,.13,21,15,0)
The default value for this field is YES.  
"^DD",3.5,3.5,.13,21,16,0)

"^DD",3.5,3.5,.13,21,17,0)

"^DD",3.5,3.5,.13,21,18,0)

"^DD",3.5,3.5,.13,"DT")
3111107
"^DD",3.5,3.5,2,0)
TYPE^RS^TRM:TERMINAL;OTH:OTHER;MT:MAGTAPE;SDP:SDP;SPL:SPOOL;BAR:BARCODE READER;HFS:HOST FILE SERVER;VTRM:VIRTUAL TERMINAL;RES:RESOURCES;CHAN:NETWORK CHANNEL;IMPC:IMAGING WORK STATION;PQ:PRINT QUEUE;^TYPE;1^Q
"^DD",3.5,3.5,2,.1)

"^DD",3.5,3.5,2,1,0)
^.1
"^DD",3.5,3.5,2,1,1,0)
^^TRIGGER^3.54^.01
"^DD",3.5,3.5,2,1,1,1)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S X=Y(0),X=X S X=X="RES" I X S X=DIV X ^DD(3.5,2,1,1,89.2) ;S Y(101)=$S($D(^%ZISL(3.54,D0,0)):^(0),1:"") S X=$P(Y(101),U,1) S D0=I(0,0) S DIU=X K Y X ^DD(3.5,2,1,1,1.1) X ^DD(3.5,2,1,1,1.4)
"^DD",3.5,3.5,2,1,1,1.1)
S X=DIV S Y(1)=$S($D(^%ZIS(1,D0,0)):^(0),1:"") S X=$P(Y(1),U,2)
"^DD",3.5,3.5,2,1,1,1.4)
S DIH=$S($D(^%ZISL(3.54,DIV(0),0)):^(0),1:""),DIV=X I $D(^(0)) S $P(^(0),U,1)=DIV,DIH=3.54,DIG=.01 D ^DICR:$O(^DD(DIH,DIG,1,0))>0
"^DD",3.5,3.5,2,1,1,2)
Q
"^DD",3.5,3.5,2,1,1,89.2)
S I(0,0)=$S($D(D0):D0,1:""),Y(1)=$S($D(^%ZIS(1,D0,0)):^(0),1:"") S X=$P(Y(1),U,2) K DIC S DIC="^%ZISL(3.54,",DIC(0)="NMFL" D ^DIC S (D,D0,DIV(0))=+Y
"^DD",3.5,3.5,2,1,1,"%D",0)
^^5^5^2930414^
"^DD",3.5,3.5,2,1,1,"%D",1,0)
Whenever the TYPE field of the DEVICE File(#3.5) is changed
"^DD",3.5,3.5,2,1,1,"%D",2,0)
to TYPE RESOURCE, the value of $I is triggered
"^DD",3.5,3.5,2,1,1,"%D",3,0)
into the NAME field of the RESOURCE File(#3.54).
"^DD",3.5,3.5,2,1,1,"%D",4,0)
This ensures that an entry in the RESOURCE File(#3.54)
"^DD",3.5,3.5,2,1,1,"%D",5,0)
is established for every device entry of TYPE RESOURCE.
"^DD",3.5,3.5,2,1,1,"CREATE CONDITION")
INTERNAL(#2)="RES"
"^DD",3.5,3.5,2,1,1,"CREATE VALUE")
#1
"^DD",3.5,3.5,2,1,1,"DELETE VALUE")
NO EFFECT
"^DD",3.5,3.5,2,1,1,"DIC")
LOOKUP
"^DD",3.5,3.5,2,1,1,"DT")
2921015
"^DD",3.5,3.5,2,1,1,"FIELD")
#1:RESOURCE
"^DD",3.5,3.5,2,1,2,0)
^^TRIGGER^3.5^35
"^DD",3.5,3.5,2,1,2,1)
X ^DD(3.5,2,1,2,1.3) I X S X=DIV S Y(1)=$S($D(^%ZIS(1,D0,1)):^(1),1:"") S X=$P(Y(1),U,10),X=X S DIU=X K Y S X=DIV S X="1" X ^DD(3.5,2,1,2,1.4)
"^DD",3.5,3.5,2,1,2,1.3)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X,Y(3)=$S($D(^%ZIS(1,D0,1)):^(1),1:""),X=Y(0) S X=X="RES",Y(1)=X,Y(2)=X S X=$P(Y(3),U,10) S X=X="",Y=X,X=Y(1),X=X&Y
"^DD",3.5,3.5,2,1,2,1.4)
S DIH=$S($D(^%ZIS(1,DIV(0),1)):^(1),1:""),DIV=X S $P(^(1),U,10)=DIV,DIH=3.5,DIG=35 D ^DICR:$O(^DD(DIH,DIG,1,0))>0
"^DD",3.5,3.5,2,1,2,2)
Q
"^DD",3.5,3.5,2,1,2,3)
Set the default value.
"^DD",3.5,3.5,2,1,2,"%D",0)
^^3^3^2961212^
"^DD",3.5,3.5,2,1,2,"%D",1,0)
Whenever a device entry is created with a TYPE RESOURCE, a default value
"^DD",3.5,3.5,2,1,2,"%D",2,0)
of '1' is triggered into the AVAILABLE SLOTS field of the RESOURCE
"^DD",3.5,3.5,2,1,2,"%D",3,0)
File(#3.54).
"^DD",3.5,3.5,2,1,2,"CREATE CONDITION")
(INTERNAL(TYPE)="RES")&(INTERNAL(#35)="")
"^DD",3.5,3.5,2,1,2,"CREATE VALUE")
"1"
"^DD",3.5,3.5,2,1,2,"DELETE VALUE")
NO EFFECT
"^DD",3.5,3.5,2,1,2,"DT")
2961212
"^DD",3.5,3.5,2,1,2,"FIELD")
#35
"^DD",3.5,3.5,2,9)
@
"^DD",3.5,3.5,2,21,0)
^^44^44^3111004^^^
"^DD",3.5,3.5,2,21,1,0)
This field has the general type of device on the CPU.  'TRM' is the most
"^DD",3.5,3.5,2,21,2,0)
common entry.
"^DD",3.5,3.5,2,21,3,0)
      TRM -- Terminal devices such as most crts and printers
"^DD",3.5,3.5,2,21,4,0)
             should be associated with a corresponding device entry
"^DD",3.5,3.5,2,21,5,0)
             with a type of 'TRM'.
"^DD",3.5,3.5,2,21,6,0)
      HFS -- Host File Server is only available on mumps platforms
"^DD",3.5,3.5,2,21,7,0)
             that exists on a layered system(e.g.: VMS, UNIX, NT, etc.).
"^DD",3.5,3.5,2,21,8,0)
             This type and the associated functionality provides
"^DD",3.5,3.5,2,21,9,0)
             the vehicle to read and write to host level files.
"^DD",3.5,3.5,2,21,10,0)
             Instead of directing reports to a printer, the results
"^DD",3.5,3.5,2,21,11,0)
             could be placed into a VMS, NT or UNIX file.  This would
"^DD",3.5,3.5,2,21,12,0)
             allow a non-mumps based statistical package or spreadsheet
"^DD",3.5,3.5,2,21,13,0)
             to use data produced by the mumps based application by
"^DD",3.5,3.5,2,21,14,0)
             simply extracting data from the host file.
"^DD",3.5,3.5,2,21,15,0)
     VTRM -- Virtual Terminal Server devices are those that are associated
"^DD",3.5,3.5,2,21,16,0)
             with a dynamically created mumps port identification($I).
"^DD",3.5,3.5,2,21,17,0)
             A generic device entry with a device type of 'VTRM'
"^DD",3.5,3.5,2,21,18,0)
             can be established for users who log into the system
"^DD",3.5,3.5,2,21,19,0)
             through terminal servers.
"^DD",3.5,3.5,2,21,20,0)
      RES -- Resources is a type used for special sequencing of tasks
"^DD",3.5,3.5,2,21,21,0)
             that do not require a particular device.
"^DD",3.5,3.5,2,21,22,0)
     CHAN -- Network Channels are high speed devices that use network
"^DD",3.5,3.5,2,21,23,0)
             protocols such as TCP/IP.
"^DD",3.5,3.5,2,21,24,0)
      OTH -- Other devices that do not fit a particular category
"^DD",3.5,3.5,2,21,25,0)
             should be given a type of 'OTH'.
"^DD",3.5,3.5,2,21,26,0)
       MT -- Magtape device should have a type of 'MT'.
"^DD",3.5,3.5,2,21,27,0)
      SPL -- Spool device is a predefined allocated disk space similar
"^DD",3.5,3.5,2,21,28,0)
             to SDP.  However, access to the spool device can be achieved
"^DD",3.5,3.5,2,21,29,0)
             from multiple users simultaneously.
"^DD",3.5,3.5,2,21,30,0)
      BAR -- Bar code reader.  This type identifies the device
"^DD",3.5,3.5,2,21,31,0)
             as a barcode reader.
"^DD",3.5,3.5,2,21,32,0)
      SDP -- Sequential Disk Processor is a predefined allocated
"^DD",3.5,3.5,2,21,33,0)
             disk space used for sequential processing.  On DSM-11
"^DD",3.5,3.5,2,21,34,0)
             and M/11+ systems, devices 59 thru 62 are reserved for SDP.
"^DD",3.5,3.5,2,21,35,0)
             On MSM, the Sequential Block Processor(SBP) is essentially
"^DD",3.5,3.5,2,21,36,0)
             the same as SDP. This has been replaced with HFS.
"^DD",3.5,3.5,2,21,37,0)
     IMPC -- Imaging work station device(reserved for future use for
"^DD",3.5,3.5,2,21,38,0)
             DHCP Imaging Project).
"^DD",3.5,3.5,2,21,39,0)
     PQ   -- Print Queues.  This type of device will be used on
"^DD",3.5,3.5,2,21,40,0)
             Cache/VMS,Linux, or Unix systems to create host files and
"^DD",3.5,3.5,2,21,41,0)
             pass them to a print server.  Print Queue devices are
"^DD",3.5,3.5,2,21,42,0)
             not used on Windows systems.
"^DD",3.5,3.5,2,21,43,0)

"^DD",3.5,3.5,2,21,44,0)

"^DD",3.5,3.5,2,"DT")
3111026
"^DD",3.52,3.52,0)
FIELD^^.09^9
"^DD",3.52,3.52,0,"DDA")
N
"^DD",3.52,3.52,0,"DT")
3111102
"^DD",3.52,3.52,0,"ID","WRITE")
D ID^ZISPQ
"^DD",3.52,3.52,0,"IX","B",3.52,.01)

"^DD",3.52,3.52,0,"IX","H",3.52,.02)

"^DD",3.52,3.52,0,"NM","PRINT QUEUE JOB")

"^DD",3.52,3.52,0,"VRPK")
XU
"^DD",3.52,3.52,.01,0)
DEVICE^R*P3.5'I^%ZIS(1,^0;1^S DIC("S")="I $P(^%ZIS(1,Y,""TYPE""),""^"")=""PQ""" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",3.52,3.52,.01,1,0)
^.1
"^DD",3.52,3.52,.01,1,1,0)
3.52^B
"^DD",3.52,3.52,.01,1,1,1)
S ^%ZIS(3.52,"B",$E(X,1,30),DA)=""
"^DD",3.52,3.52,.01,1,1,2)
K ^%ZIS(3.52,"B",$E(X,1,30),DA)
"^DD",3.52,3.52,.01,3)
Select the device which controls the print queue.
"^DD",3.52,3.52,.01,12)
Allows only PRINT QUEUE type devices to be selected.
"^DD",3.52,3.52,.01,12.1)
S DIC("S")="I $P(^%ZIS(1,Y,""TYPE""),""^"")=""PQ"""
"^DD",3.52,3.52,.01,21,0)
^^4^4^3111107^^^
"^DD",3.52,3.52,.01,21,1,0)
Identifies the device that the user selected when the print request was made. 
"^DD",3.52,3.52,.01,21,2,0)

"^DD",3.52,3.52,.01,21,3,0)

"^DD",3.52,3.52,.01,21,4,0)

"^DD",3.52,3.52,.01,"DT")
3111107
"^DD",3.52,3.52,.02,0)
DT/TM HOST FILE CREATED^RD^^0;2^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",3.52,3.52,.02,1,0)
^.1
"^DD",3.52,3.52,.02,1,1,0)
3.52^H
"^DD",3.52,3.52,.02,1,1,1)
S ^%ZIS(3.52,"H",$E(X,1,30),DA)=""
"^DD",3.52,3.52,.02,1,1,2)
K ^%ZIS(3.52,"H",$E(X,1,30),DA)
"^DD",3.52,3.52,.02,1,1,"%D",0)
^^3^3^3111123^
"^DD",3.52,3.52,.02,1,1,"%D",1,0)
This cross-referene is used to find print jobs by the date/time that the 
"^DD",3.52,3.52,.02,1,1,"%D",2,0)
host file was created.
"^DD",3.52,3.52,.02,1,1,"%D",3,0)

"^DD",3.52,3.52,.02,1,1,"DT")
3111123
"^DD",3.52,3.52,.02,3)
Enter the date and time that the host file was created.
"^DD",3.52,3.52,.02,21,0)
^^4^4^3111025^^
"^DD",3.52,3.52,.02,21,1,0)
This is the date/time that the host file was created.
"^DD",3.52,3.52,.02,21,2,0)

"^DD",3.52,3.52,.02,21,3,0)

"^DD",3.52,3.52,.02,21,4,0)

"^DD",3.52,3.52,.02,"DT")
3111123
"^DD",3.52,3.52,.03,0)
DT/TM PASSED TO PRINT SERVER^RDI^^0;3^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",3.52,3.52,.03,3)
Enter the date and time that the host file was passed to the print server.
"^DD",3.52,3.52,.03,21,0)
^^4^4^3111102^^
"^DD",3.52,3.52,.03,21,1,0)
This is the date and time that the host file was passed to the print server.
"^DD",3.52,3.52,.03,21,2,0)
No value indicates that the file was not yet passed to the print server.
"^DD",3.52,3.52,.03,21,3,0)

"^DD",3.52,3.52,.03,21,4,0)

"^DD",3.52,3.52,.03,23,0)
^^1^1^3111004^
"^DD",3.52,3.52,.03,23,1,0)

"^DD",3.52,3.52,.03,"DT")
3111107
"^DD",3.52,3.52,.04,0)
OWNER^RP200'I^VA(200,^0;4^Q
"^DD",3.52,3.52,.04,3)
Select the user who initiated the print job.
"^DD",3.52,3.52,.04,21,0)
^^4^4^3111102^^^
"^DD",3.52,3.52,.04,21,1,0)
This field indicates the user that made the print request.
"^DD",3.52,3.52,.04,21,2,0)

"^DD",3.52,3.52,.04,21,3,0)

"^DD",3.52,3.52,.04,21,4,0)

"^DD",3.52,3.52,.04,23,0)
^^1^1^3111004^
"^DD",3.52,3.52,.04,23,1,0)

"^DD",3.52,3.52,.04,"DT")
3111102
"^DD",3.52,3.52,.05,0)
OS PRINT QUEUE^F^^0;5^K:$L(X)>31!($L(X)<1) X
"^DD",3.52,3.52,.05,3)
Answer must be 1-31 characters in length.
"^DD",3.52,3.52,.05,21,0)
^^3^3^3111025^
"^DD",3.52,3.52,.05,21,1,0)
This is the name of the print queue that the print job should be submitted to.
"^DD",3.52,3.52,.05,21,2,0)
The print queue is created within the host operating system. 
"^DD",3.52,3.52,.05,21,3,0)

"^DD",3.52,3.52,.05,"DT")
3111025
"^DD",3.52,3.52,.06,0)
HOST FILE^RF^^0;6^K:$L(X)>20!($L(X)<3) X
"^DD",3.52,3.52,.06,3)
Enter a unique name (3-20 characters) for the host file.
"^DD",3.52,3.52,.06,21,0)
^^5^5^3111021^^
"^DD",3.52,3.52,.06,21,1,0)
The unique name of the host file. The name will have the following format:
"^DD",3.52,3.52,.06,21,2,0)

"^DD",3.52,3.52,.06,21,3,0)
PQ$JOB_<record IEN>.TXT
"^DD",3.52,3.52,.06,21,4,0)

"^DD",3.52,3.52,.06,21,5,0)

"^DD",3.52,3.52,.06,"DT")
3111102
"^DD",3.52,3.52,.07,0)
STATUS^RS^O:FILE OPENED;OE:ERROR OPENING FILE;AE:APPLICATION ERROR BEFORE CLOSING FILE;Q:PRINT JOB QUEUED;QE:ERROR SUBMITTING JOB TO QUEUE;P:FILE PRINTED, DELETED;D:FILE DELETED, NOT PRINTED;^0;7^Q
"^DD",3.52,3.52,.07,3)
Enter the status of the host file.
"^DD",3.52,3.52,.07,21,0)
^^3^3^3111021^^
"^DD",3.52,3.52,.07,21,1,0)
The current status of the host file. 
"^DD",3.52,3.52,.07,21,2,0)

"^DD",3.52,3.52,.07,21,3,0)

"^DD",3.52,3.52,.07,"DT")
3111102
"^DD",3.52,3.52,.08,0)
OS JOB ID^F^^0;8^K:$L(X)>30!($L(X)<3) X
"^DD",3.52,3.52,.08,3)
Enter the job identifier (3-30 characters) that was assigned when the host file was submitted for printing.
"^DD",3.52,3.52,.08,21,0)
^^4^4^3111102^^
"^DD",3.52,3.52,.08,21,1,0)
This is the identifier assigned by the OS to the print job.  The format
"^DD",3.52,3.52,.08,21,2,0)
is system dependent.
"^DD",3.52,3.52,.08,21,3,0)

"^DD",3.52,3.52,.08,21,4,0)

"^DD",3.52,3.52,.08,"DT")
3111102
"^DD",3.52,3.52,.09,0)
HFS DIRECTORY^S^1:PRIMARY;2:SECONDARY;^0;9^Q
"^DD",3.52,3.52,.09,3)
Is the print queue on the primary system or the secondary system?
"^DD",3.52,3.52,.09,21,0)
^^5^5^3111102^^
"^DD",3.52,3.52,.09,21,1,0)
This describes the system on which the print queue is located.
"^DD",3.52,3.52,.09,21,2,0)
This field is important in mixed OS environments.  The print queues and 
"^DD",3.52,3.52,.09,21,3,0)
host files are accessible only on the system that they were created on.
"^DD",3.52,3.52,.09,21,4,0)

"^DD",3.52,3.52,.09,21,5,0)

"^DD",3.52,3.52,.09,"DT")
3111102
"^DIC",3.52,3.52,0)
PRINT QUEUE JOB^3.52
"^DIC",3.52,3.52,0,"GL")
^%ZIS(3.52,
"^DIC",3.52,3.52,"%",0)
^1.005^^0
"^DIC",3.52,3.52,"%D",0)
^^12^12^3111006^^
"^DIC",3.52,3.52,"%D",1,0)
This file is used to record print jobs passed to a print server.  Under
"^DIC",3.52,3.52,"%D",2,0)
Linux a CUPS is used to provide print services and to manage print queues.
"^DIC",3.52,3.52,"%D",3,0)

"^DIC",3.52,3.52,"%D",4,0)
Print jobs are passed to the print server via a host file.  Each time a host
"^DIC",3.52,3.52,"%D",5,0)
file is created a new entry will be created in this file.  The file will be
"^DIC",3.52,3.52,"%D",6,0)
purged of old entries on a regular basis.
"^DIC",3.52,3.52,"%D",7,0)

"^DIC",3.52,3.52,"%D",8,0)
The principle use of this file is to insure that the name of the host file is
"^DIC",3.52,3.52,"%D",9,0)
unique.  A secondary use is to track the host files, for example, so that
"^DIC",3.52,3.52,"%D",10,0)
old files can be purged regularly, or to aid in troubleshooting of problems
"^DIC",3.52,3.52,"%D",11,0)
involving print queues. 
"^DIC",3.52,3.52,"%D",12,0)

"^DIC",3.52,"B","PRINT QUEUE JOB",3.52)

"BLD",1395,6)
^485
**END**
**END**
